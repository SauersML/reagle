[1m[92m   Compiling[0m reagle v0.1.0 (/home/runner/work/reagle/reagle/Rust)
[1m[33mwarning[0m[1m: unused imports: `CodedPbwt`, `CodedStep`, `RefPanelCoded`, and `compute_step_starts`[0m
  [1m[94m--> [0msrc/data/storage/mod.rs:14:23
   [1m[94m|[0m
[1m[94m14[0m [1m[94m|[0m pub use coded_steps::{CodedStep, RefPanelCoded, CodedPbwt, compute_step_starts};
   [1m[94m|[0m                       [1m[33m^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

[1m[33mwarning[0m[1m: unused import: `genetic_map::GeneticMap`[0m
  [1m[94m--> [0msrc/data/mod.rs:19:9
   [1m[94m|[0m
[1m[94m19[0m [1m[94m|[0m pub use genetic_map::GeneticMap;
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused import: `Samples`[0m
  [1m[94m--> [0msrc/data/mod.rs:20:40
   [1m[94m|[0m
[1m[94m20[0m [1m[94m|[0m pub use haplotype::{HapIdx, SampleIdx, Samples};
   [1m[94m|[0m                                        [1m[33m^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `Allele`, `Marker`, and `Markers`[0m
  [1m[94m--> [0msrc/data/mod.rs:21:18
   [1m[94m|[0m
[1m[94m21[0m [1m[94m|[0m pub use marker::{Allele, Marker, MarkerIdx, Markers};
   [1m[94m|[0m                  [1m[33m^^^^^^[0m  [1m[33m^^^^^^[0m             [1m[33m^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `DenseColumn`, `DictionaryColumn`, `GenotypeColumn`, `GenotypeMatrix`, `GenotypeView`, `MutableGenotypes`, and `SparseColumn`[0m
  [1m[94m--> [0msrc/data/mod.rs:23:5
   [1m[94m|[0m
[1m[94m23[0m [1m[94m|[0m     DenseColumn, DictionaryColumn, GenotypeColumn, GenotypeMatrix, GenotypeView, MutableGenotypes,
   [1m[94m|[0m     [1m[33m^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m24[0m [1m[94m|[0m     SparseColumn,
   [1m[94m|[0m     [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `StreamWindow`, `StreamingConfig`, and `StreamingVcfReader`[0m
  [1m[94m--> [0msrc/io/mod.rs:10:21
   [1m[94m|[0m
[1m[94m10[0m [1m[94m|[0m pub use streaming::{StreamingVcfReader, StreamingConfig, StreamWindow};
   [1m[94m|[0m                     [1m[33m^^^^^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `ImputationQuality`, `MarkerImputationStats`, `VcfReader`, and `VcfWriter`[0m
  [1m[94m--> [0msrc/io/mod.rs:11:15
   [1m[94m|[0m
[1m[94m11[0m [1m[94m|[0m pub use vcf::{VcfReader, VcfWriter, ImputationQuality, MarkerImputationStats};
   [1m[94m|[0m               [1m[33m^^^^^^^^^[0m  [1m[33m^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `SlidingWindowIterator`, `WindowBuilder`, and `Window`[0m
  [1m[94m--> [0msrc/io/mod.rs:12:18
   [1m[94m|[0m
[1m[94m12[0m [1m[94m|[0m pub use window::{Window, WindowBuilder, SlidingWindowIterator};
   [1m[94m|[0m                  [1m[33m^^^^^^[0m  [1m[33m^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `HmmResult` and `LiStephensHmm`[0m
  [1m[94m--> [0msrc/model/mod.rs:16:15
   [1m[94m|[0m
[1m[94m16[0m [1m[94m|[0m pub use hmm::{LiStephensHmm, HmmResult};
   [1m[94m|[0m               [1m[33m^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `Ibs2Segment` and `Ibs2`[0m
  [1m[94m--> [0msrc/model/mod.rs:17:16
   [1m[94m|[0m
[1m[94m17[0m [1m[94m|[0m pub use ibs2::{Ibs2, Ibs2Segment};
   [1m[94m|[0m                [1m[33m^^^^[0m  [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `CodedStepsConfig`, `CodedSteps`, and `ImpStates`[0m
  [1m[94m--> [0msrc/model/mod.rs:18:22
   [1m[94m|[0m
[1m[94m18[0m [1m[94m|[0m pub use imp_states::{ImpStates, CodedSteps, CodedStepsConfig};
   [1m[94m|[0m                      [1m[33m^^^^^^^^^[0m  [1m[33m^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused import: `parameters::ModelParams`[0m
  [1m[94m--> [0msrc/model/mod.rs:19:9
   [1m[94m|[0m
[1m[94m19[0m [1m[94m|[0m pub use parameters::ModelParams;
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `PbwtDivUpdater` and `PbwtUpdater`[0m
  [1m[94m--> [0msrc/model/mod.rs:20:16
   [1m[94m|[0m
[1m[94m20[0m [1m[94m|[0m pub use pbwt::{PbwtUpdater, PbwtDivUpdater};
   [1m[94m|[0m                [1m[33m^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused import: `workspace::Workspace`[0m
 [1m[94m--> [0msrc/utils/mod.rs:7:9
  [1m[94m|[0m
[1m[94m7[0m [1m[94m|[0m pub use workspace::Workspace;
  [1m[94m|[0m         [1m[33m^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `ImputationQuality`, `MarkerImputationStats`, and `VcfWriter`[0m
  [1m[94m--> [0msrc/io/mod.rs:11:26
   [1m[94m|[0m
[1m[94m11[0m [1m[94m|[0m pub use vcf::{VcfReader, VcfWriter, ImputationQuality, MarkerImputationStats};
   [1m[94m|[0m                          [1m[33m^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `err_rate` and `li_stephens_p_mismatch` are never used[0m
   [1m[94m--> [0msrc/config.rs:200:12
    [1m[94m|[0m
[1m[94m131[0m [1m[94m|[0m impl Config {
    [1m[94m|[0m [1m[94m-----------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m200[0m [1m[94m|[0m     pub fn err_rate(&self, n_haps: usize) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m209[0m [1m[94m|[0m     pub fn li_stephens_p_mismatch(n_haps: usize) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^[0m
    [1m[94m|[0m
    [1m[94m= [0m[1mnote[0m: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

[1m[33mwarning[0m[1m: constant `MIN_GEN_DIST` is never used[0m
  [1m[94m--> [0msrc/data/genetic_map.rs:23:11
   [1m[94m|[0m
[1m[94m23[0m [1m[94m|[0m pub const MIN_GEN_DIST: f64 = 1e-8;
   [1m[94m|[0m           [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:42:12
    [1m[94m|[0m
[1m[94m 40[0m [1m[94m|[0m impl GeneticMap {
    [1m[94m|[0m [1m[94m---------------[0m [1m[94massociated items in this implementation[0m
[1m[94m 41[0m [1m[94m|[0m     /// Create a new genetic map
[1m[94m 42[0m [1m[94m|[0m     pub fn new(chrom: ChromIdx, positions: Vec<u32>, gen_positions: Vec<f64>) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m 53[0m [1m[94m|[0m     pub fn empty(chrom: ChromIdx) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^[0m
[1m[94m...[0m
[1m[94m 66[0m [1m[94m|[0m     pub fn position_map(scale_factor: f64) -> PositionMap {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m194[0m [1m[94m|[0m     pub fn slice(&self, min_bp: u32, max_bp: u32) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^[0m
[1m[94m...[0m
[1m[94m238[0m [1m[94m|[0m     pub fn len(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m243[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m248[0m [1m[94m|[0m     pub fn chrom(&self) -> ChromIdx {
    [1m[94m|[0m            [1m[33m^^^^^[0m

[1m[33mwarning[0m[1m: struct `PositionMap` is never constructed[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:262:12
    [1m[94m|[0m
[1m[94m262[0m [1m[94m|[0m pub struct PositionMap {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `with_scale`, `gen_pos`, and `gen_dist` are never used[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:268:12
    [1m[94m|[0m
[1m[94m266[0m [1m[94m|[0m impl PositionMap {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94massociated items in this implementation[0m
[1m[94m267[0m [1m[94m|[0m     /// Create a new position map with default scale factor (1 cM per Mb)
[1m[94m268[0m [1m[94m|[0m     pub fn new() -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m275[0m [1m[94m|[0m     pub fn with_scale(scale_factor: f64) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m280[0m [1m[94m|[0m     pub fn gen_pos(&self, phys_pos: u32) -> f64 {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m285[0m [1m[94m|[0m     pub fn gen_dist(&self, pos1: u32, pos2: u32) -> f64 {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `MarkerMap` is never constructed[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:294:12
    [1m[94m|[0m
[1m[94m294[0m [1m[94m|[0m pub struct MarkerMap {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:306:12
    [1m[94m|[0m
[1m[94m302[0m [1m[94m|[0m impl MarkerMap {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m306[0m [1m[94m|[0m     pub fn create(markers: &Markers, gen_map: &GeneticMap) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m325[0m [1m[94m|[0m     pub fn from_gen_map_with_min_dist(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m362[0m [1m[94m|[0m     pub fn from_gen_map(markers: &Markers, gen_map: &GeneticMap) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m388[0m [1m[94m|[0m     pub fn from_positions(markers: &Markers) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m417[0m [1m[94m|[0m     fn mean_single_base_gen_dist(markers: &Markers, gen_map: &GeneticMap) -> f64 {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m440[0m [1m[94m|[0m     pub fn len(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m445[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m450[0m [1m[94m|[0m     pub fn gen_pos(&self, index: usize) -> f64 {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m455[0m [1m[94m|[0m     pub fn gen_dist(&self, index: usize) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m460[0m [1m[94m|[0m     pub fn gen_positions(&self) -> &[f64] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m465[0m [1m[94m|[0m     pub fn gen_distances(&self) -> &[f32] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m478[0m [1m[94m|[0m     pub fn p_recomb(&self, recomb_intensity: f32) -> Vec<f32> {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m497[0m [1m[94m|[0m     pub fn restrict(&self, indices: &[usize]) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: method `insert` is never used[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:557:12
    [1m[94m|[0m
[1m[94m534[0m [1m[94m|[0m impl GeneticMaps {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m557[0m [1m[94m|[0m     pub fn insert(&mut self, chrom: ChromIdx, map: GeneticMap) {
    [1m[94m|[0m            [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: field `id_to_idx` is never read[0m
   [1m[94m--> [0msrc/data/haplotype.rs:114:5
    [1m[94m|[0m
[1m[94m108[0m [1m[94m|[0m pub struct Samples {
    [1m[94m|[0m            [1m[94m-------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m114[0m [1m[94m|[0m     id_to_idx: HashMap<Arc<str>, SampleIdx>,
    [1m[94m|[0m     [1m[33m^^^^^^^^^[0m
    [1m[94m|[0m
    [1m[94m= [0m[1mnote[0m: `Samples` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/haplotype.rs:119:12
    [1m[94m|[0m
[1m[94m117[0m [1m[94m|[0m impl Samples {
    [1m[94m|[0m [1m[94m------------[0m [1m[94massociated items in this implementation[0m
[1m[94m118[0m [1m[94m|[0m     /// Create an empty sample collection
[1m[94m119[0m [1m[94m|[0m     pub fn new() -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m141[0m [1m[94m|[0m     pub fn from_ids_with_ploidy(ids: Vec<String>, is_diploid: Vec<bool>) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m163[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m176[0m [1m[94m|[0m     pub fn id(&self, idx: SampleIdx) -> &str {
    [1m[94m|[0m            [1m[33m^^[0m
[1m[94m...[0m
[1m[94m181[0m [1m[94m|[0m     pub fn index_of(&self, id: &str) -> Option<SampleIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m186[0m [1m[94m|[0m     pub fn is_diploid(&self, idx: SampleIdx) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m191[0m [1m[94m|[0m     pub fn push(&mut self, id: String, diploid: bool) {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m205[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = SampleIdx> {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m210[0m [1m[94m|[0m     pub fn hap_iter(&self) -> impl Iterator<Item = HapIdx> + '_ {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m221[0m [1m[94m|[0m     pub fn combine(first: &Samples, second: &Samples) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `is_snv`, `is_missing`, `is_empty`, and `complement` are never used[0m
   [1m[94m--> [0msrc/data/marker.rs:77:12
    [1m[94m|[0m
[1m[94m 52[0m [1m[94m|[0m impl Allele {
    [1m[94m|[0m [1m[94m-----------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 77[0m [1m[94m|[0m     pub fn is_snv(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m 82[0m [1m[94m|[0m     pub fn is_missing(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 96[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m101[0m [1m[94m|[0m     pub fn complement(&self) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: field `end` is never read[0m
   [1m[94m--> [0msrc/data/marker.rs:135:9
    [1m[94m|[0m
[1m[94m128[0m [1m[94m|[0m pub struct Marker {
    [1m[94m|[0m            [1m[94m------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m135[0m [1m[94m|[0m     pub end: u32,
    [1m[94m|[0m         [1m[33m^^^[0m
    [1m[94m|[0m
    [1m[94m= [0m[1mnote[0m: `Marker` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/marker.rs:146:12
    [1m[94m|[0m
[1m[94m144[0m [1m[94m|[0m impl Marker {
    [1m[94m|[0m [1m[94m-----------[0m [1m[94massociated items in this implementation[0m
[1m[94m145[0m [1m[94m|[0m     /// Create a new marker
[1m[94m146[0m [1m[94m|[0m     pub fn new(
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m164[0m [1m[94m|[0m     pub fn n_alleles(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m169[0m [1m[94m|[0m     pub fn is_biallelic(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m174[0m [1m[94m|[0m     pub fn is_snv(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m179[0m [1m[94m|[0m     pub fn allele(&self, idx: usize) -> Option<&Allele> {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m188[0m [1m[94m|[0m     pub fn bits_per_allele(&self) -> u32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m217[0m [1m[94m|[0m     pub fn span(&self) -> u32 {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m222[0m [1m[94m|[0m     pub fn overlaps(&self, start: u32, end: u32) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m227[0m [1m[94m|[0m     pub fn has_end_value(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `AlleleMapping` is never constructed[0m
   [1m[94m--> [0msrc/data/marker.rs:236:12
    [1m[94m|[0m
[1m[94m236[0m [1m[94m|[0m pub struct AlleleMapping {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `identity`, `no_match`, `map_allele`, and `is_valid` are never used[0m
   [1m[94m--> [0msrc/data/marker.rs:247:12
    [1m[94m|[0m
[1m[94m245[0m [1m[94m|[0m impl AlleleMapping {
    [1m[94m|[0m [1m[94m------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m246[0m [1m[94m|[0m     /// Create an identity mapping (no transformation needed)
[1m[94m247[0m [1m[94m|[0m     pub fn identity(n_alleles: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m256[0m [1m[94m|[0m     pub fn no_match(n_alleles: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m266[0m [1m[94m|[0m     pub fn map_allele(&self, targ_allele: u8) -> Option<u8> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m273[0m [1m[94m|[0m     pub fn is_valid(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `compute_allele_mapping` is never used[0m
   [1m[94m--> [0msrc/data/marker.rs:292:8
    [1m[94m|[0m
[1m[94m292[0m [1m[94m|[0m pub fn compute_allele_mapping(targ: &Marker, ref_marker: &Marker) -> Option<AlleleMapping> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `try_direct_match` is never used[0m
   [1m[94m--> [0msrc/data/marker.rs:319:4
    [1m[94m|[0m
[1m[94m319[0m [1m[94m|[0m fn try_direct_match(targ: &Marker, ref_marker: &Marker) -> Option<AlleleMapping> {
    [1m[94m|[0m    [1m[33m^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `try_strand_flip` is never used[0m
   [1m[94m--> [0msrc/data/marker.rs:362:4
    [1m[94m|[0m
[1m[94m362[0m [1m[94m|[0m fn try_strand_flip(targ: &Marker, ref_marker: &Marker) -> Option<AlleleMapping> {
    [1m[94m|[0m    [1m[33m^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `is_strand_ambiguous` is never used[0m
   [1m[94m--> [0msrc/data/marker.rs:405:8
    [1m[94m|[0m
[1m[94m405[0m [1m[94m|[0m pub fn is_strand_ambiguous(marker: &Marker) -> bool {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `from_vec`, `is_empty`, `get`, `iter`, and `restrict` are never used[0m
   [1m[94m--> [0msrc/data/marker.rs:461:12
    [1m[94m|[0m
[1m[94m454[0m [1m[94m|[0m impl Markers {
    [1m[94m|[0m [1m[94m------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m461[0m [1m[94m|[0m     pub fn from_vec(markers: Vec<Marker>, chrom_names: Vec<Arc<str>>) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m474[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m479[0m [1m[94m|[0m     pub fn get(&self, idx: MarkerIdx) -> Option<&Marker> {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m512[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = &Marker> {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m517[0m [1m[94m|[0m     pub fn restrict(&self, start: usize, end: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: variant `Dictionary` is never constructed[0m
  [1m[94m--> [0msrc/data/storage/mod.rs:37:5
   [1m[94m|[0m
[1m[94m26[0m [1m[94m|[0m pub enum GenotypeColumn {
   [1m[94m|[0m          [1m[94m--------------[0m [1m[94mvariant in this enum[0m
[1m[94m...[0m
[1m[94m37[0m [1m[94m|[0m     Dictionary(DictionaryColumn),
   [1m[94m|[0m     [1m[33m^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `GenotypeColumn` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `n_haplotypes`, `alt_count`, `maf`, `size_bytes`, `is_biallelic`, and `iter` are never used[0m
   [1m[94m--> [0msrc/data/storage/mod.rs:52:12
    [1m[94m|[0m
[1m[94m 40[0m [1m[94m|[0m impl GenotypeColumn {
    [1m[94m|[0m [1m[94m-------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 52[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 61[0m [1m[94m|[0m     pub fn alt_count(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 70[0m [1m[94m|[0m     pub fn maf(&self) -> f64 {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m 81[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m126[0m [1m[94m|[0m     pub fn is_biallelic(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m135[0m [1m[94m|[0m     pub fn iter(&self) -> Box<dyn Iterator<Item = u8> + '_> {
    [1m[94m|[0m            [1m[33m^^^^[0m

[1m[33mwarning[0m[1m: struct `CodedStep` is never constructed[0m
  [1m[94m--> [0msrc/data/storage/coded_steps.rs:24:12
   [1m[94m|[0m
[1m[94m24[0m [1m[94m|[0m pub struct CodedStep {
   [1m[94m|[0m            [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/storage/coded_steps.rs:41:12
    [1m[94m|[0m
[1m[94m 39[0m [1m[94m|[0m impl CodedStep {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94massociated items in this implementation[0m
[1m[94m 40[0m [1m[94m|[0m     /// Create a new coded step from genotype data
[1m[94m 41[0m [1m[94m|[0m     pub fn new(gt: &GenotypeMatrix, start: usize, end: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m 98[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m103[0m [1m[94m|[0m     pub fn n_patterns(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m108[0m [1m[94m|[0m     pub fn n_haps(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m113[0m [1m[94m|[0m     pub fn pattern(&self, hap: HapIdx) -> u16 {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m118[0m [1m[94m|[0m     pub fn allele(&self, pattern: u16, marker_offset: usize) -> u8 {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m123[0m [1m[94m|[0m     pub fn hap_allele(&self, hap: HapIdx, marker_offset: usize) -> u8 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m129[0m [1m[94m|[0m     pub fn first_allele(&self, pattern: u16) -> u8 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m134[0m [1m[94m|[0m     pub fn pattern_alleles(&self, pattern: u16) -> &[u8] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m139[0m [1m[94m|[0m     pub fn haps_with_pattern(&self, pattern: u16) -> Vec<HapIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m149[0m [1m[94m|[0m     pub fn compression_ratio(&self) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `RefPanelCoded` is never constructed[0m
   [1m[94m--> [0msrc/data/storage/coded_steps.rs:160:12
    [1m[94m|[0m
[1m[94m160[0m [1m[94m|[0m pub struct RefPanelCoded {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/storage/coded_steps.rs:171:12
    [1m[94m|[0m
[1m[94m169[0m [1m[94m|[0m impl RefPanelCoded {
    [1m[94m|[0m [1m[94m------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m170[0m [1m[94m|[0m     /// Create coded reference panel from genotype matrix
[1m[94m171[0m [1m[94m|[0m     pub fn new(gt: &GenotypeMatrix, step_starts: &[usize]) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m190[0m [1m[94m|[0m     pub fn from_gen_positions(gt: &GenotypeMatrix, gen_positions: &[f64], step_cm: f64) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m196[0m [1m[94m|[0m     pub fn n_steps(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m201[0m [1m[94m|[0m     pub fn step(&self, idx: usize) -> &CodedStep {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m206[0m [1m[94m|[0m     pub fn step_for_marker(&self, marker: usize) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m216[0m [1m[94m|[0m     pub fn allele(&self, marker: usize, hap: HapIdx) -> u8 {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m224[0m [1m[94m|[0m     pub fn total_patterns(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m229[0m [1m[94m|[0m     pub fn avg_compression_ratio(&self) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m238[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m243[0m [1m[94m|[0m     pub fn n_haps(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: function `compute_step_starts` is never used[0m
   [1m[94m--> [0msrc/data/storage/coded_steps.rs:249:8
    [1m[94m|[0m
[1m[94m249[0m [1m[94m|[0m pub fn compute_step_starts(gen_positions: &[f64], step_cm: f64) -> Vec<usize> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `CodedPbwt` is never constructed[0m
   [1m[94m--> [0msrc/data/storage/coded_steps.rs:274:12
    [1m[94m|[0m
[1m[94m274[0m [1m[94m|[0m pub struct CodedPbwt {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `update`, `find_ibs`, `reset`, and `current_step` are never used[0m
   [1m[94m--> [0msrc/data/storage/coded_steps.rs:285:12
    [1m[94m|[0m
[1m[94m283[0m [1m[94m|[0m impl CodedPbwt {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94massociated items in this implementation[0m
[1m[94m284[0m [1m[94m|[0m     /// Create new PBWT for coded reference panel
[1m[94m285[0m [1m[94m|[0m     pub fn new(n_haps: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m294[0m [1m[94m|[0m     pub fn update(&mut self, step: &CodedStep) {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m332[0m [1m[94m|[0m     pub fn find_ibs(&self, target_pattern: u16, step: &CodedStep, n_matches: usize) -> Vec<HapIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m367[0m [1m[94m|[0m     pub fn reset(&mut self) {
    [1m[94m|[0m            [1m[33m^^^^^[0m
[1m[94m...[0m
[1m[94m376[0m [1m[94m|[0m     pub fn current_step(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple methods are never used[0m
   [1m[94m--> [0msrc/data/storage/dense.rs:90:12
    [1m[94m|[0m
[1m[94m 25[0m [1m[94m|[0m impl DenseColumn {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 90[0m [1m[94m|[0m     pub fn set(&mut self, hap: HapIdx, allele: u8) {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m103[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m108[0m [1m[94m|[0m     pub fn bits_per_allele(&self) -> u8 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m113[0m [1m[94m|[0m     pub fn alt_count(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m122[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = u8> + '_ {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m127[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m133[0m [1m[94m|[0m     pub fn raw_bits(&self) -> &BitSlice<u64, Lsb0> {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m138[0m [1m[94m|[0m     pub fn raw_u64s(&self) -> &[u64] {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: field `n_markers` is never read[0m
  [1m[94m--> [0msrc/data/storage/dictionary.rs:22:5
   [1m[94m|[0m
[1m[94m13[0m [1m[94m|[0m pub struct DictionaryColumn {
   [1m[94m|[0m            [1m[94m----------------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m22[0m [1m[94m|[0m     n_markers: u32,
   [1m[94m|[0m     [1m[33m^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `DictionaryColumn` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/storage/dictionary.rs:30:12
    [1m[94m|[0m
[1m[94m 28[0m [1m[94m|[0m impl DictionaryColumn {
    [1m[94m|[0m [1m[94m---------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m 29[0m [1m[94m|[0m     /// Create a new dictionary column from patterns and mapping
[1m[94m 30[0m [1m[94m|[0m     pub fn new(
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m 45[0m [1m[94m|[0m     pub fn compress(
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m112[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m117[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m122[0m [1m[94m|[0m     pub fn n_patterns(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m127[0m [1m[94m|[0m     pub fn compression_ratio(&self) -> f64 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m132[0m [1m[94m|[0m     pub fn is_biallelic(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m137[0m [1m[94m|[0m     pub fn alt_count(&self, marker_offset: usize) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m148[0m [1m[94m|[0m     pub fn iter_marker(&self, marker_offset: usize) -> impl Iterator<Item = u8> + '_ {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m153[0m [1m[94m|[0m     pub fn pattern_index(&self, hap: HapIdx) -> u16 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m158[0m [1m[94m|[0m     pub fn haplotypes_with_pattern(&self, pattern_idx: u16) -> Vec<HapIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m168[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: fields `is_phased` and `is_reversed` are never read[0m
  [1m[94m--> [0msrc/data/storage/matrix.rs:26:5
   [1m[94m|[0m
[1m[94m15[0m [1m[94m|[0m pub struct GenotypeMatrix {
   [1m[94m|[0m            [1m[94m--------------[0m [1m[94mfields in this struct[0m
[1m[94m...[0m
[1m[94m26[0m [1m[94m|[0m     is_phased: bool,
   [1m[94m|[0m     [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m29[0m [1m[94m|[0m     is_reversed: bool,
   [1m[94m|[0m     [1m[33m^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `GenotypeMatrix` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/storage/matrix.rs:51:12
    [1m[94m|[0m
[1m[94m 32[0m [1m[94m|[0m impl GenotypeMatrix {
    [1m[94m|[0m [1m[94m-------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m 51[0m [1m[94m|[0m     pub fn empty(samples: Arc<Samples>) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^[0m
[1m[94m...[0m
[1m[94m 77[0m [1m[94m|[0m     pub fn is_phased(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 82[0m [1m[94m|[0m     pub fn is_reversed(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 97[0m [1m[94m|[0m     pub fn samples(&self) -> &Samples {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m118[0m [1m[94m|[0m     pub fn genotype(&self, marker: MarkerIdx, sample: SampleIdx) -> (u8, u8) {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m125[0m [1m[94m|[0m     pub fn restrict(&self, start: usize, end: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m136[0m [1m[94m|[0m     pub fn restrict_markers(&self, indices: &[usize]) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m153[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = (MarkerIdx, &Marker, &GenotypeColumn)> {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m161[0m [1m[94m|[0m     pub fn marker_indices(&self) -> impl Iterator<Item = MarkerIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m166[0m [1m[94m|[0m     pub fn haplotype_indices(&self) -> impl Iterator<Item = HapIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m171[0m [1m[94m|[0m     pub fn haplotype(&self, hap: HapIdx) -> Vec<u8> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m176[0m [1m[94m|[0m     pub fn alleles_at_marker(&self, marker: MarkerIdx) -> Vec<u8> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m184[0m [1m[94m|[0m     pub fn set_phased(&mut self, phased: bool) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m189[0m [1m[94m|[0m     pub fn set_reversed(&mut self, reversed: bool) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m194[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m200[0m [1m[94m|[0m     pub fn column_mut(&mut self, idx: MarkerIdx) -> &mut GenotypeColumn {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m205[0m [1m[94m|[0m     pub fn set_column(&mut self, idx: MarkerIdx, column: GenotypeColumn) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m210[0m [1m[94m|[0m     pub fn push(&mut self, marker: Marker, column: GenotypeColumn) {
    [1m[94m|[0m            [1m[33m^^^^[0m

[1m[33mwarning[0m[1m: struct `GenotypeMatrixView` is never constructed[0m
   [1m[94m--> [0msrc/data/storage/matrix.rs:217:12
    [1m[94m|[0m
[1m[94m217[0m [1m[94m|[0m pub struct GenotypeMatrixView<'a> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/storage/matrix.rs:224:12
    [1m[94m|[0m
[1m[94m222[0m [1m[94m|[0m impl<'a> GenotypeMatrixView<'a> {
    [1m[94m|[0m [1m[94m-------------------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m223[0m [1m[94m|[0m     /// Create a view into a matrix
[1m[94m224[0m [1m[94m|[0m     pub fn new(matrix: &'a GenotypeMatrix, marker_range: Range<usize>) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m229[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m234[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m239[0m [1m[94m|[0m     pub fn allele(&self, marker_offset: usize, hap: HapIdx) -> u8 {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m245[0m [1m[94m|[0m     pub fn marker(&self, marker_offset: usize) -> &Marker {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m251[0m [1m[94m|[0m     pub fn column(&self, marker_offset: usize) -> &GenotypeColumn {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m257[0m [1m[94m|[0m     pub fn to_owned(&self) -> GenotypeMatrix {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: field `n_haps` is never read[0m
  [1m[94m--> [0msrc/data/storage/mutable.rs:17:5
   [1m[94m|[0m
[1m[94m13[0m [1m[94m|[0m pub struct MutableGenotypes {
   [1m[94m|[0m            [1m[94m----------------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m17[0m [1m[94m|[0m     n_haps: usize,
   [1m[94m|[0m     [1m[33m^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `MutableGenotypes` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/storage/mutable.rs:22:12
    [1m[94m|[0m
[1m[94m 20[0m [1m[94m|[0m impl MutableGenotypes {
    [1m[94m|[0m [1m[94m---------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m 21[0m [1m[94m|[0m     /// Create from existing allele data
[1m[94m 22[0m [1m[94m|[0m     pub fn new(n_markers: usize, n_haps: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m 48[0m [1m[94m|[0m     pub fn n_haps(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m 54[0m [1m[94m|[0m     pub fn get(&self, marker: usize, hap: HapIdx) -> u8 {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m 60[0m [1m[94m|[0m     pub fn set(&mut self, marker: usize, hap: HapIdx, allele: u8) {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m 72[0m [1m[94m|[0m     pub fn marker_alleles_mut(&mut self, marker: usize) -> &mut [u8] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 91[0m [1m[94m|[0m     pub fn swap_range(&mut self, markers: &[usize], hap1: HapIdx, hap2: HapIdx) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m100[0m [1m[94m|[0m     pub fn copy_from(&mut self, other: &MutableGenotypes) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m109[0m [1m[94m|[0m     pub fn raw_alleles(&self) -> &[Vec<u8>] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: field `n_haplotypes` is never read[0m
  [1m[94m--> [0msrc/data/storage/sparse.rs:15:5
   [1m[94m|[0m
[1m[94m10[0m [1m[94m|[0m pub struct SparseColumn {
   [1m[94m|[0m            [1m[94m------------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m15[0m [1m[94m|[0m     n_haplotypes: u32,
   [1m[94m|[0m     [1m[33m^^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `SparseColumn` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/storage/sparse.rs:34:12
    [1m[94m|[0m
[1m[94m 22[0m [1m[94m|[0m impl SparseColumn {
    [1m[94m|[0m [1m[94m-----------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m 34[0m [1m[94m|[0m     pub fn from_alleles(alleles: &[u8]) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 73[0m [1m[94m|[0m     pub fn is_carrier(&self, hap: HapIdx) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 78[0m [1m[94m|[0m     pub fn carriers(&self) -> &[HapIdx] {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 83[0m [1m[94m|[0m     pub fn n_carriers(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 92[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 97[0m [1m[94m|[0m     pub fn maf(&self) -> f64 {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m107[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m113[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = u8> + '_ {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m118[0m [1m[94m|[0m     pub fn is_inverted(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `SparseMultiAllelic` is never constructed[0m
   [1m[94m--> [0msrc/data/storage/sparse.rs:125:12
    [1m[94m|[0m
[1m[94m125[0m [1m[94m|[0m pub struct SparseMultiAllelic {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `from_entries`, `get`, `n_haplotypes`, `n_entries`, and `size_bytes` are never used[0m
   [1m[94m--> [0msrc/data/storage/sparse.rs:135:12
    [1m[94m|[0m
[1m[94m133[0m [1m[94m|[0m impl SparseMultiAllelic {
    [1m[94m|[0m [1m[94m-----------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m134[0m [1m[94m|[0m     /// Create from entries
[1m[94m135[0m [1m[94m|[0m     pub fn from_entries(mut entries: Vec<(HapIdx, u8)>, n_haplotypes: u32) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m145[0m [1m[94m|[0m     pub fn get(&self, hap: HapIdx) -> u8 {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m153[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m158[0m [1m[94m|[0m     pub fn n_entries(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m163[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: enum `GenotypeView` is never used[0m
  [1m[94m--> [0msrc/data/storage/view.rs:14:10
   [1m[94m|[0m
[1m[94m14[0m [1m[94m|[0m pub enum GenotypeView<'a> {
   [1m[94m|[0m          [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `n_markers`, `n_haplotypes`, `allele`, `marker`, and `markers` are never used[0m
  [1m[94m--> [0msrc/data/storage/view.rs:26:12
   [1m[94m|[0m
[1m[94m24[0m [1m[94m|[0m impl<'a> GenotypeView<'a> {
   [1m[94m|[0m [1m[94m-------------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m25[0m [1m[94m|[0m     /// Get the number of markers
[1m[94m26[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m34[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m42[0m [1m[94m|[0m     pub fn allele(&self, marker: MarkerIdx, hap: HapIdx) -> u8 {
   [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m50[0m [1m[94m|[0m     pub fn marker(&self, marker: MarkerIdx) -> &Marker {
   [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m58[0m [1m[94m|[0m     pub fn markers(&self) -> &Markers {
   [1m[94m|[0m            [1m[33m^^^^^^^[0m

[1m[33mwarning[0m[1m: variants `InvalidData` and `Algorithm` are never constructed[0m
  [1m[94m--> [0msrc/error.rs:21:5
   [1m[94m|[0m
[1m[94m10[0m [1m[94m|[0m pub enum ReagleError {
   [1m[94m|[0m          [1m[94m-----------[0m [1m[94mvariants in this enum[0m
[1m[94m...[0m
[1m[94m21[0m [1m[94m|[0m     InvalidData { message: String },
   [1m[94m|[0m     [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m25[0m [1m[94m|[0m     Algorithm { message: String },
   [1m[94m|[0m     [1m[33m^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `ReagleError` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: associated functions `invalid_data` and `algorithm` are never used[0m
  [1m[94m--> [0msrc/error.rs:52:12
   [1m[94m|[0m
[1m[94m43[0m [1m[94m|[0m impl ReagleError {
   [1m[94m|[0m [1m[94m----------------[0m [1m[94massociated functions in this implementation[0m
[1m[94m...[0m
[1m[94m52[0m [1m[94m|[0m     pub fn invalid_data(message: impl Into<String>) -> Self {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m59[0m [1m[94m|[0m     pub fn algorithm(message: impl Into<String>) -> Self {
   [1m[94m|[0m            [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `StreamingConfig` is never constructed[0m
  [1m[94m--> [0msrc/io/streaming.rs:29:12
   [1m[94m|[0m
[1m[94m29[0m [1m[94m|[0m pub struct StreamingConfig {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `StreamWindow` is never constructed[0m
  [1m[94m--> [0msrc/io/streaming.rs:53:12
   [1m[94m|[0m
[1m[94m53[0m [1m[94m|[0m pub struct StreamWindow {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `BufferedMarker` is never constructed[0m
  [1m[94m--> [0msrc/io/streaming.rs:73:8
   [1m[94m|[0m
[1m[94m73[0m [1m[94m|[0m struct BufferedMarker {
   [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `StreamingVcfReader` is never constructed[0m
  [1m[94m--> [0msrc/io/streaming.rs:80:12
   [1m[94m|[0m
[1m[94m80[0m [1m[94m|[0m pub struct StreamingVcfReader {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/io/streaming.rs:107:12
    [1m[94m|[0m
[1m[94m105[0m [1m[94m|[0m impl StreamingVcfReader {
    [1m[94m|[0m [1m[94m-----------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m106[0m [1m[94m|[0m     /// Open a VCF file for streaming
[1m[94m107[0m [1m[94m|[0m     pub fn open(
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m129[0m [1m[94m|[0m     pub fn from_reader(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m183[0m [1m[94m|[0m     pub fn samples(&self) -> &Samples {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m188[0m [1m[94m|[0m     pub fn samples_arc(&self) -> Arc<Samples> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m195[0m [1m[94m|[0m     pub fn next_window(&mut self) -> Result<Option<StreamWindow>> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m288[0m [1m[94m|[0m     fn fill_buffer_to_window(&mut self) -> Result<()> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m315[0m [1m[94m|[0m     fn read_next_marker(&mut self) -> Result<Option<BufferedMarker>> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m335[0m [1m[94m|[0m     fn parse_vcf_line(&mut self, line: &str) -> Result<BufferedMarker> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `parse_gt` is never used[0m
   [1m[94m--> [0msrc/io/streaming.rs:411:4
    [1m[94m|[0m
[1m[94m411[0m [1m[94m|[0m fn parse_gt(gt: &str) -> (u8, u8) {
    [1m[94m|[0m    [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `parse_allele_char` is never used[0m
   [1m[94m--> [0msrc/io/streaming.rs:438:4
    [1m[94m|[0m
[1m[94m438[0m [1m[94m|[0m fn parse_allele_char(s: &str) -> u8 {
    [1m[94m|[0m    [1m[33m^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `StreamingPipeline` is never constructed[0m
   [1m[94m--> [0msrc/io/streaming.rs:452:12
    [1m[94m|[0m
[1m[94m452[0m [1m[94m|[0m pub struct StreamingPipeline<F>
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new` and `run` are never used[0m
   [1m[94m--> [0msrc/io/streaming.rs:465:12
    [1m[94m|[0m
[1m[94m460[0m [1m[94m|[0m [1m[94m/[0m impl<F> StreamingPipeline<F>
[1m[94m461[0m [1m[94m|[0m [1m[94m|[0m where
[1m[94m462[0m [1m[94m|[0m [1m[94m|[0m     F: FnMut(&StreamWindow) -> Result<Vec<u8>>,
    [1m[94m|[0m [1m[94m|_______________________________________________-[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m465[0m [1m[94m|[0m       pub fn new(reader: StreamingVcfReader, processor: F) -> Self {
    [1m[94m|[0m              [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m470[0m [1m[94m|[0m       pub fn run(&mut self, output_path: &Path) -> Result<()> {
    [1m[94m|[0m              [1m[33m^^^[0m

[1m[33mwarning[0m[1m: method `add_haploid` is never used[0m
  [1m[94m--> [0msrc/io/vcf.rs:64:12
   [1m[94m|[0m
[1m[94m35[0m [1m[94m|[0m impl MarkerImputationStats {
   [1m[94m|[0m [1m[94m--------------------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m64[0m [1m[94m|[0m     pub fn add_haploid(&mut self, probs: &[f32]) {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated function `new_biallelic` is never used[0m
   [1m[94m--> [0msrc/io/vcf.rs:132:12
    [1m[94m|[0m
[1m[94m121[0m [1m[94m|[0m impl ImputationQuality {
    [1m[94m|[0m [1m[94m----------------------[0m [1m[94massociated function in this implementation[0m
[1m[94m...[0m
[1m[94m132[0m [1m[94m|[0m     pub fn new_biallelic(n_markers: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: field `header` is never read[0m
   [1m[94m--> [0msrc/io/vcf.rs:159:5
    [1m[94m|[0m
[1m[94m157[0m [1m[94m|[0m pub struct VcfReader {
    [1m[94m|[0m            [1m[94m---------[0m [1m[94mfield in this struct[0m
[1m[94m158[0m [1m[94m|[0m     /// The VCF header
[1m[94m159[0m [1m[94m|[0m     header: Header,
    [1m[94m|[0m     [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: methods `samples` and `header` are never used[0m
   [1m[94m--> [0msrc/io/vcf.rs:225:12
    [1m[94m|[0m
[1m[94m164[0m [1m[94m|[0m impl VcfReader {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m225[0m [1m[94m|[0m     pub fn samples(&self) -> &Samples {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m235[0m [1m[94m|[0m     pub fn header(&self) -> &Header {
    [1m[94m|[0m            [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: method `write_imputed` is never used[0m
   [1m[94m--> [0msrc/io/vcf.rs:554:12
    [1m[94m|[0m
[1m[94m460[0m [1m[94m|[0m impl VcfWriter {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m554[0m [1m[94m|[0m     pub fn write_imputed(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `Window` is never constructed[0m
  [1m[94m--> [0msrc/io/window.rs:12:12
   [1m[94m|[0m
[1m[94m12[0m [1m[94m|[0m pub struct Window {
   [1m[94m|[0m            [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: struct `WindowIndices` is never constructed[0m
  [1m[94m--> [0msrc/io/window.rs:31:12
   [1m[94m|[0m
[1m[94m31[0m [1m[94m|[0m pub struct WindowIndices {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `n_markers` and `n_output_markers` are never used[0m
  [1m[94m--> [0msrc/io/window.rs:50:12
   [1m[94m|[0m
[1m[94m48[0m [1m[94m|[0m impl WindowIndices {
   [1m[94m|[0m [1m[94m------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m49[0m [1m[94m|[0m     /// Number of markers in the window
[1m[94m50[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m55[0m [1m[94m|[0m     pub fn n_output_markers(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `n_markers`, `n_samples`, `n_haplotypes`, `has_ref`, and `gen_dist` are never used[0m
  [1m[94m--> [0msrc/io/window.rs:62:12
   [1m[94m|[0m
[1m[94m60[0m [1m[94m|[0m impl Window {
   [1m[94m|[0m [1m[94m-----------[0m [1m[94massociated items in this implementation[0m
[1m[94m61[0m [1m[94m|[0m     /// Create a new window
[1m[94m62[0m [1m[94m|[0m     pub fn new(
   [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m79[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m84[0m [1m[94m|[0m     pub fn n_samples(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m89[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m94[0m [1m[94m|[0m     pub fn has_ref(&self) -> bool {
   [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m99[0m [1m[94m|[0m     pub fn gen_dist(&self, m1: usize, m2: usize) -> f64 {
   [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `WindowBuilder` is never constructed[0m
   [1m[94m--> [0msrc/io/window.rs:107:12
    [1m[94m|[0m
[1m[94m107[0m [1m[94m|[0m pub struct WindowBuilder {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `window_cm`, `overlap_cm`, `max_markers`, `buffer_cm`, and `build` are never used[0m
   [1m[94m--> [0msrc/io/window.rs:120:12
    [1m[94m|[0m
[1m[94m118[0m [1m[94m|[0m impl WindowBuilder {
    [1m[94m|[0m [1m[94m------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m119[0m [1m[94m|[0m     /// Create a new window builder with default settings
[1m[94m120[0m [1m[94m|[0m     pub fn new() -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m130[0m [1m[94m|[0m     pub fn window_cm(mut self, cm: f32) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m136[0m [1m[94m|[0m     pub fn overlap_cm(mut self, cm: f32) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m142[0m [1m[94m|[0m     pub fn max_markers(mut self, n: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m148[0m [1m[94m|[0m     pub fn buffer_cm(mut self, cm: f32) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m154[0m [1m[94m|[0m     pub fn build<'a>(
    [1m[94m|[0m            [1m[33m^^^^^[0m

[1m[33mwarning[0m[1m: struct `SlidingWindowIterator` is never constructed[0m
   [1m[94m--> [0msrc/io/window.rs:178:12
    [1m[94m|[0m
[1m[94m178[0m [1m[94m|[0m pub struct SlidingWindowIterator<'a> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `find_window_end`, and `find_overlap_start` are never used[0m
   [1m[94m--> [0msrc/io/window.rs:192:12
    [1m[94m|[0m
[1m[94m190[0m [1m[94m|[0m impl<'a> SlidingWindowIterator<'a> {
    [1m[94m|[0m [1m[94m----------------------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m191[0m [1m[94m|[0m     /// Create a new sliding window iterator
[1m[94m192[0m [1m[94m|[0m     pub fn new(
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m214[0m [1m[94m|[0m     fn find_window_end(&self, start: usize) -> usize {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m239[0m [1m[94m|[0m     fn find_overlap_start(&self, end: usize) -> usize {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `HmmResult` is never constructed[0m
  [1m[94m--> [0msrc/model/hmm.rs:22:12
   [1m[94m|[0m
[1m[94m22[0m [1m[94m|[0m pub struct HmmResult {
   [1m[94m|[0m            [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `HmmUpdater` is never constructed[0m
  [1m[94m--> [0msrc/model/hmm.rs:32:12
   [1m[94m|[0m
[1m[94m32[0m [1m[94m|[0m pub struct HmmUpdater;
   [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated functions `fwd_update`, `bwd_update`, `fwd_update_alleles`, and `bwd_update_alleles` are never used[0m
   [1m[94m--> [0msrc/model/hmm.rs:50:12
    [1m[94m|[0m
[1m[94m 34[0m [1m[94m|[0m impl HmmUpdater {
    [1m[94m|[0m [1m[94m---------------[0m [1m[94massociated functions in this implementation[0m
[1m[94m...[0m
[1m[94m 50[0m [1m[94m|[0m     pub fn fwd_update(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 81[0m [1m[94m|[0m     pub fn bwd_update(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m106[0m [1m[94m|[0m     pub fn fwd_update_alleles(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m131[0m [1m[94m|[0m     pub fn bwd_update_alleles(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `LiStephensHmm` is never constructed[0m
   [1m[94m--> [0msrc/model/hmm.rs:160:12
    [1m[94m|[0m
[1m[94m160[0m [1m[94m|[0m pub struct LiStephensHmm<'a> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/model/hmm.rs:179:12
    [1m[94m|[0m
[1m[94m171[0m [1m[94m|[0m impl<'a> LiStephensHmm<'a> {
    [1m[94m|[0m [1m[94m--------------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m179[0m [1m[94m|[0m     pub fn new(
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m194[0m [1m[94m|[0m     pub fn from_gen_dists(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m208[0m [1m[94m|[0m     fn gen_dists_to_p_recomb(gen_dists: &[f64], recomb_intensity: f32) -> Vec<f32> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m222[0m [1m[94m|[0m     pub fn n_states(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m227[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m233[0m [1m[94m|[0m     pub fn state_allele(&self, marker: MarkerIdx, state: usize) -> u8 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m238[0m [1m[94m|[0m     pub fn state_alleles(&self, marker: MarkerIdx) -> Vec<u8> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m257[0m [1m[94m|[0m     pub fn forward_backward(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m355[0m [1m[94m|[0m     fn forward_pass(
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m397[0m [1m[94m|[0m     fn sample_path(&self, state_probs: &[Vec<f32>], n_markers: usize, n_states: usize) -> Vec<usize> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m417[0m [1m[94m|[0m     pub fn compute_dosage(&self, marker: MarkerIdx, state_probs: &[f32]) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `PhasingHmm` is never constructed[0m
   [1m[94m--> [0msrc/model/hmm.rs:434:12
    [1m[94m|[0m
[1m[94m434[0m [1m[94m|[0m pub struct PhasingHmm<'a> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new` and `phase_sample` are never used[0m
   [1m[94m--> [0msrc/model/hmm.rs:443:12
    [1m[94m|[0m
[1m[94m441[0m [1m[94m|[0m impl<'a> PhasingHmm<'a> {
    [1m[94m|[0m [1m[94m-----------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m442[0m [1m[94m|[0m     /// Create a new phasing HMM
[1m[94m443[0m [1m[94m|[0m     pub fn new(ref_gt: &'a GenotypeMatrix, params: &'a ModelParams) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m460[0m [1m[94m|[0m     pub fn phase_sample(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: constant `MIN_IBS2_CM` is never used[0m
  [1m[94m--> [0msrc/model/ibs2.rs:19:7
   [1m[94m|[0m
[1m[94m19[0m [1m[94m|[0m const MIN_IBS2_CM: f64 = 2.0;
   [1m[94m|[0m       [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: constant `MAX_IBS2_GAP_CM` is never used[0m
  [1m[94m--> [0msrc/model/ibs2.rs:22:7
   [1m[94m|[0m
[1m[94m22[0m [1m[94m|[0m const MAX_IBS2_GAP_CM: f64 = 4.0;
   [1m[94m|[0m       [1m[33m^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `Ibs2Segment` is never constructed[0m
  [1m[94m--> [0msrc/model/ibs2.rs:26:12
   [1m[94m|[0m
[1m[94m26[0m [1m[94m|[0m pub struct Ibs2Segment {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `contains`, and `len` are never used[0m
  [1m[94m--> [0msrc/model/ibs2.rs:36:12
   [1m[94m|[0m
[1m[94m35[0m [1m[94m|[0m impl Ibs2Segment {
   [1m[94m|[0m [1m[94m----------------[0m [1m[94massociated items in this implementation[0m
[1m[94m36[0m [1m[94m|[0m     pub fn new(other_sample: SampleIdx, start: usize, incl_end: usize) -> Self {
   [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m45[0m [1m[94m|[0m     pub fn contains(&self, marker: usize) -> bool {
   [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m50[0m [1m[94m|[0m     pub fn len(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^[0m

[1m[33mwarning[0m[1m: struct `Ibs2` is never constructed[0m
  [1m[94m--> [0msrc/model/ibs2.rs:56:12
   [1m[94m|[0m
[1m[94m56[0m [1m[94m|[0m pub struct Ibs2 {
   [1m[94m|[0m            [1m[33m^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/model/ibs2.rs:70:12
    [1m[94m|[0m
[1m[94m 63[0m [1m[94m|[0m impl Ibs2 {
    [1m[94m|[0m [1m[94m---------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m 70[0m [1m[94m|[0m     pub fn new(gt: &GenotypeMatrix, gen_map: &GeneticMap, maf: &[f32]) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m 92[0m [1m[94m|[0m     fn build_sample_segments(
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m118[0m [1m[94m|[0m     fn merge_segments(segments: Vec<Ibs2Segment>, gen_map: &GeneticMap) -> Vec<Ibs2Segment> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m147[0m [1m[94m|[0m     fn gap_cm(prev: &Ibs2Segment, next: &Ibs2Segment, gen_map: &GeneticMap) -> f64 {
    [1m[94m|[0m        [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m153[0m [1m[94m|[0m     fn extend_segments(
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m182[0m [1m[94m|[0m     fn filter_by_length(segments: Vec<Ibs2Segment>, gen_map: &GeneticMap) -> Vec<Ibs2Segment> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m195[0m [1m[94m|[0m     fn is_ibs2_at(gt: &GenotypeMatrix, marker: usize, s1: SampleIdx, s2: SampleIdx) -> bool {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m207[0m [1m[94m|[0m     fn are_phase_consistent(a1: u8, a2: u8, b1: u8, b2: u8) -> bool {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m212[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m217[0m [1m[94m|[0m     pub fn n_samples(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m222[0m [1m[94m|[0m     pub fn n_segments(&self, sample: SampleIdx) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m230[0m [1m[94m|[0m     pub fn are_ibs2(&self, sample: SampleIdx, other: SampleIdx, marker: usize) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m250[0m [1m[94m|[0m     pub fn are_ibs2_in_interval(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m279[0m [1m[94m|[0m     pub fn segments(&self, sample: SampleIdx) -> &[Ibs2Segment] {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m287[0m [1m[94m|[0m     pub fn ibs2_samples_at(&self, sample: SampleIdx, marker: usize) -> Vec<SampleIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `Ibs2Markers` is never constructed[0m
   [1m[94m--> [0msrc/model/ibs2.rs:306:8
    [1m[94m|[0m
[1m[94m306[0m [1m[94m|[0m struct Ibs2Markers {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `MIN_MAF`, `new`, and `len` are never used[0m
   [1m[94m--> [0msrc/model/ibs2.rs:313:11
    [1m[94m|[0m
[1m[94m311[0m [1m[94m|[0m impl Ibs2Markers {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94massociated items in this implementation[0m
[1m[94m312[0m [1m[94m|[0m     /// Minimum MAF for informative markers
[1m[94m313[0m [1m[94m|[0m     const MIN_MAF: f32 = 0.05;
    [1m[94m|[0m           [1m[33m^^^^^^^[0m
[1m[94m314[0m [1m[94m|[0m
[1m[94m315[0m [1m[94m|[0m     fn new(gt: &GenotypeMatrix, maf: &[f32]) -> Self {
    [1m[94m|[0m        [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m329[0m [1m[94m|[0m     fn len(&self) -> usize {
    [1m[94m|[0m        [1m[33m^^^[0m

[1m[33mwarning[0m[1m: struct `Ibs2Sets` is never constructed[0m
   [1m[94m--> [0msrc/model/ibs2.rs:335:8
    [1m[94m|[0m
[1m[94m335[0m [1m[94m|[0m struct Ibs2Sets {
    [1m[94m|[0m        [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new` and `segments_for_sample` are never used[0m
   [1m[94m--> [0msrc/model/ibs2.rs:342:8
    [1m[94m|[0m
[1m[94m341[0m [1m[94m|[0m impl Ibs2Sets {
    [1m[94m|[0m [1m[94m-------------[0m [1m[94massociated items in this implementation[0m
[1m[94m342[0m [1m[94m|[0m     fn new(gt: &GenotypeMatrix, ibs2_markers: &Ibs2Markers) -> Self {
    [1m[94m|[0m        [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m391[0m [1m[94m|[0m     fn segments_for_sample(&self, sample: SampleIdx) -> Vec<Ibs2Segment> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: method `find_ibs_haps` is never used[0m
   [1m[94m--> [0msrc/model/imp_states.rs:363:12
    [1m[94m|[0m
[1m[94m210[0m [1m[94m|[0m impl ImpIbs {
    [1m[94m|[0m [1m[94m-----------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m363[0m [1m[94m|[0m     pub fn find_ibs_haps(&self, target_allele: u8, step: usize) -> Vec<u32> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: fields `ne`, `n_haps`, and `use_em` are never read[0m
  [1m[94m--> [0msrc/model/parameters.rs:14:9
   [1m[94m|[0m
[1m[94m11[0m [1m[94m|[0m pub struct ModelParams {
   [1m[94m|[0m            [1m[94m-----------[0m [1m[94mfields in this struct[0m
[1m[94m...[0m
[1m[94m14[0m [1m[94m|[0m     pub ne: u64,
   [1m[94m|[0m         [1m[33m^^[0m
[1m[94m...[0m
[1m[94m29[0m [1m[94m|[0m     pub n_haps: usize,
   [1m[94m|[0m         [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m44[0m [1m[94m|[0m     pub use_em: bool,
   [1m[94m|[0m         [1m[33m^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `ModelParams` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `switch_prob`, `no_switch_prob`, `ne_from_recomb_intensity`, `set_ne`, and `set_n_haps` are never used[0m
   [1m[94m--> [0msrc/model/parameters.rs:177:12
    [1m[94m|[0m
[1m[94m 47[0m [1m[94m|[0m impl ModelParams {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m177[0m [1m[94m|[0m     pub fn switch_prob(&self, gen_dist_cm: f64) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m182[0m [1m[94m|[0m     pub fn no_switch_prob(&self, gen_dist_cm: f64) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m222[0m [1m[94m|[0m     pub fn ne_from_recomb_intensity(&self) -> u64 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m227[0m [1m[94m|[0m     pub fn set_ne(&mut self, ne: u64) {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m240[0m [1m[94m|[0m     pub fn set_n_haps(&mut self, n_haps: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `merge` and `sum_switch_probs` are never used[0m
   [1m[94m--> [0msrc/model/parameters.rs:297:12
    [1m[94m|[0m
[1m[94m276[0m [1m[94m|[0m impl ParamEstimates {
    [1m[94m|[0m [1m[94m-------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m297[0m [1m[94m|[0m     pub fn merge(&mut self, other: &ParamEstimates) {
    [1m[94m|[0m            [1m[33m^^^^^[0m
[1m[94m...[0m
[1m[94m307[0m [1m[94m|[0m     pub fn sum_switch_probs(&self) -> f64 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `PbwtUpdater` is never constructed[0m
  [1m[94m--> [0msrc/model/pbwt.rs:25:12
   [1m[94m|[0m
[1m[94m25[0m [1m[94m|[0m pub struct PbwtUpdater {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `n_haps`, `update`, `update_with`, and `ensure_capacity` are never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:37:12
    [1m[94m|[0m
[1m[94m 32[0m [1m[94m|[0m impl PbwtUpdater {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m 37[0m [1m[94m|[0m     pub fn new(n_haps: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m 46[0m [1m[94m|[0m     pub fn n_haps(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m 56[0m [1m[94m|[0m     pub fn update(&mut self, alleles: &[u8], n_alleles: usize, prefix: &mut [u32]) {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m 87[0m [1m[94m|[0m     pub fn update_with<F>(&mut self, get_allele: F, n_alleles: usize, prefix: &mut [u32])
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m116[0m [1m[94m|[0m     fn ensure_capacity(&mut self, n_alleles: usize) {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `n_haps` and `bwd_update` are never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:156:12
    [1m[94m|[0m
[1m[94m143[0m [1m[94m|[0m impl PbwtDivUpdater {
    [1m[94m|[0m [1m[94m-------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m156[0m [1m[94m|[0m     pub fn n_haps(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m228[0m [1m[94m|[0m     pub fn bwd_update(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `SimpleDivUpdater` is never constructed[0m
   [1m[94m--> [0msrc/model/pbwt.rs:387:12
    [1m[94m|[0m
[1m[94m387[0m [1m[94m|[0m pub struct SimpleDivUpdater {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new` and `update` are never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:393:12
    [1m[94m|[0m
[1m[94m392[0m [1m[94m|[0m impl SimpleDivUpdater {
    [1m[94m|[0m [1m[94m---------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m393[0m [1m[94m|[0m     pub fn new(n_haps: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m401[0m [1m[94m|[0m     pub fn update(
    [1m[94m|[0m            [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: fields `n_haps`, `fwd_updater`, and `bwd_updater` are never read[0m
   [1m[94m--> [0msrc/model/pbwt.rs:451:5
    [1m[94m|[0m
[1m[94m441[0m [1m[94m|[0m pub struct PbwtIbs {
    [1m[94m|[0m            [1m[94m-------[0m [1m[94mfields in this struct[0m
[1m[94m...[0m
[1m[94m451[0m [1m[94m|[0m     n_haps: usize,
    [1m[94m|[0m     [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m454[0m [1m[94m|[0m     fwd_updater: PbwtDivUpdater,
    [1m[94m|[0m     [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m457[0m [1m[94m|[0m     bwd_updater: PbwtDivUpdater,
    [1m[94m|[0m     [1m[33m^^^^^^^^^^^[0m
    [1m[94m|[0m
    [1m[94m= [0m[1mnote[0m: `PbwtIbs` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: multiple methods are never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:475:12
    [1m[94m|[0m
[1m[94m460[0m [1m[94m|[0m impl PbwtIbs {
    [1m[94m|[0m [1m[94m------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m475[0m [1m[94m|[0m     pub fn reset(&mut self) {
    [1m[94m|[0m            [1m[33m^^^^^[0m
[1m[94m...[0m
[1m[94m488[0m [1m[94m|[0m     pub fn fwd_update(&mut self, alleles: &[u8], n_alleles: usize, marker: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m499[0m [1m[94m|[0m     pub fn bwd_update(&mut self, alleles: &[u8], n_alleles: usize, marker: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m530[0m [1m[94m|[0m     pub fn find_position(&self, hap: HapIdx, use_backward: bool) -> Option<usize> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m627[0m [1m[94m|[0m     pub fn select_ibs_hap(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m647[0m [1m[94m|[0m     pub fn select_states_for_external_target(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m696[0m [1m[94m|[0m     pub fn find_allele_region(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `BidirectionalPhaseResult` is never constructed[0m
   [1m[94m--> [0msrc/model/pbwt.rs:734:12
    [1m[94m|[0m
[1m[94m734[0m [1m[94m|[0m pub struct BidirectionalPhaseResult {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `add`, `n_hets`, and `n_confident` are never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:745:12
    [1m[94m|[0m
[1m[94m743[0m [1m[94m|[0m impl BidirectionalPhaseResult {
    [1m[94m|[0m [1m[94m-----------------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m744[0m [1m[94m|[0m     /// Create a new result with the given capacity
[1m[94m745[0m [1m[94m|[0m     pub fn new(capacity: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m754[0m [1m[94m|[0m     pub fn add(&mut self, marker: usize, decision: bool, confident: bool) {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m761[0m [1m[94m|[0m     pub fn n_hets(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m766[0m [1m[94m|[0m     pub fn n_confident(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `run_bidirectional_pbwt_phasing` is never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:787:8
    [1m[94m|[0m
[1m[94m787[0m [1m[94m|[0m pub fn run_bidirectional_pbwt_phasing(
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `build_pbwt_matches` is never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:860:4
    [1m[94m|[0m
[1m[94m860[0m [1m[94m|[0m fn build_pbwt_matches(
    [1m[94m|[0m    [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `WindowResult` is never constructed[0m
  [1m[94m--> [0msrc/pipelines/imputation.rs:36:12
   [1m[94m|[0m
[1m[94m36[0m [1m[94m|[0m pub struct WindowResult {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated function `new` is never used[0m
  [1m[94m--> [0msrc/pipelines/imputation.rs:47:12
   [1m[94m|[0m
[1m[94m45[0m [1m[94m|[0m impl WindowResult {
   [1m[94m|[0m [1m[94m-----------------[0m [1m[94massociated function in this implementation[0m
[1m[94m46[0m [1m[94m|[0m     /// Create new window result
[1m[94m47[0m [1m[94m|[0m     pub fn new(n_markers: usize, n_samples: usize, indices: WindowIndices) -> Self {
   [1m[94m|[0m            [1m[33m^^^[0m

[1m[33mwarning[0m[1m: function `splice_window_results` is never used[0m
  [1m[94m--> [0msrc/pipelines/imputation.rs:68:8
   [1m[94m|[0m
[1m[94m68[0m [1m[94m|[0m pub fn splice_window_results(
   [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `impute_haplotype_internal` is never used[0m
   [1m[94m--> [0msrc/pipelines/imputation.rs:648:4
    [1m[94m|[0m
[1m[94m648[0m [1m[94m|[0m fn impute_haplotype_internal(
    [1m[94m|[0m    [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `impute_haplotype` is never used[0m
   [1m[94m--> [0msrc/pipelines/imputation.rs:696:8
    [1m[94m|[0m
[1m[94m696[0m [1m[94m|[0m pub fn impute_haplotype(
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `ImpLSBaum` is never constructed[0m
   [1m[94m--> [0msrc/pipelines/imputation.rs:716:12
    [1m[94m|[0m
[1m[94m716[0m [1m[94m|[0m pub struct ImpLSBaum<'a> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new` and `impute` are never used[0m
   [1m[94m--> [0msrc/pipelines/imputation.rs:725:12
    [1m[94m|[0m
[1m[94m723[0m [1m[94m|[0m impl<'a> ImpLSBaum<'a> {
    [1m[94m|[0m [1m[94m----------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m724[0m [1m[94m|[0m     /// Create a new imputation engine
[1m[94m725[0m [1m[94m|[0m     pub fn new(
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m742[0m [1m[94m|[0m     pub fn impute(&mut self, target_alleles: &[u8]) -> Vec<f32> {
    [1m[94m|[0m            [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: struct `StageMarkers` is never constructed[0m
  [1m[94m--> [0msrc/pipelines/phasing.rs:34:12
   [1m[94m|[0m
[1m[94m34[0m [1m[94m|[0m pub struct StageMarkers {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `classify`, `is_stage1`, `n_stage1`, `stage1_marker`, and `is_allele_low_freq` are never used[0m
   [1m[94m--> [0msrc/pipelines/phasing.rs:56:12
    [1m[94m|[0m
[1m[94m 49[0m [1m[94m|[0m impl StageMarkers {
    [1m[94m|[0m [1m[94m-----------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m 56[0m [1m[94m|[0m     pub fn classify(
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m160[0m [1m[94m|[0m     pub fn is_stage1(&self, marker: usize) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m165[0m [1m[94m|[0m     pub fn n_stage1(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m170[0m [1m[94m|[0m     pub fn stage1_marker(&self, stage1_idx: usize) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m175[0m [1m[94m|[0m     pub fn is_allele_low_freq(&self, marker: usize, allele: u8) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `Workspace` is never constructed[0m
  [1m[94m--> [0msrc/utils/workspace.rs:16:12
   [1m[94m|[0m
[1m[94m16[0m [1m[94m|[0m pub struct Workspace {
   [1m[94m|[0m            [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/utils/workspace.rs:53:12
    [1m[94m|[0m
[1m[94m 51[0m [1m[94m|[0m impl Workspace {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94massociated items in this implementation[0m
[1m[94m 52[0m [1m[94m|[0m     /// Create a new workspace with given capacities
[1m[94m 53[0m [1m[94m|[0m     pub fn new(n_states: usize, n_markers: usize, n_haps: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m 70[0m [1m[94m|[0m     pub fn minimal() -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m 75[0m [1m[94m|[0m     pub fn resize(&mut self, n_states: usize, n_markers: usize, n_haps: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m 98[0m [1m[94m|[0m     pub fn clear(&mut self) {
    [1m[94m|[0m            [1m[33m^^^^^[0m
[1m[94m...[0m
[1m[94m111[0m [1m[94m|[0m     pub fn reset_pbwt(&mut self, n_haps: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m123[0m [1m[94m|[0m     pub fn init_fwd_uniform(&mut self, n_states: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m131[0m [1m[94m|[0m     pub fn init_bwd_ones(&mut self, n_states: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m138[0m [1m[94m|[0m     pub fn set_seed(&mut self, seed: u64) {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m143[0m [1m[94m|[0m     pub fn next_u64(&mut self) -> u64 {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m153[0m [1m[94m|[0m     pub fn next_f32(&mut self) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m158[0m [1m[94m|[0m     pub fn sample_index(&mut self, probs: &[f32]) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `ImpWorkspace` is never constructed[0m
   [1m[94m--> [0msrc/utils/workspace.rs:184:12
    [1m[94m|[0m
[1m[94m184[0m [1m[94m|[0m pub struct ImpWorkspace {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `resize`, and `clear` are never used[0m
   [1m[94m--> [0msrc/utils/workspace.rs:206:12
    [1m[94m|[0m
[1m[94m204[0m [1m[94m|[0m impl ImpWorkspace {
    [1m[94m|[0m [1m[94m-----------------[0m [1m[94massociated items in this implementation[0m
[1m[94m205[0m [1m[94m|[0m     /// Create a new imputation workspace
[1m[94m206[0m [1m[94m|[0m     pub fn new(n_states: usize, n_markers: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m218[0m [1m[94m|[0m     pub fn resize(&mut self, n_states: usize, n_markers: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m228[0m [1m[94m|[0m     pub fn clear(&mut self) {
    [1m[94m|[0m            [1m[33m^^^^^[0m

[1m[33mwarning[0m: `reagle` (bin "reagle") generated 127 warnings (run `cargo fix --bin "reagle" -p reagle` to apply 14 suggestions)
[1m[33mwarning[0m[1m: method `err_rate` is never used[0m
   [1m[94m--> [0msrc/config.rs:200:12
    [1m[94m|[0m
[1m[94m131[0m [1m[94m|[0m impl Config {
    [1m[94m|[0m [1m[94m-----------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m200[0m [1m[94m|[0m     pub fn err_rate(&self, n_haps: usize) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
    [1m[94m|[0m
    [1m[94m= [0m[1mnote[0m: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

[1m[33mwarning[0m[1m: associated items `position_map`, `len`, `is_empty`, and `chrom` are never used[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:66:12
    [1m[94m|[0m
[1m[94m 40[0m [1m[94m|[0m impl GeneticMap {
    [1m[94m|[0m [1m[94m---------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m 66[0m [1m[94m|[0m     pub fn position_map(scale_factor: f64) -> PositionMap {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m238[0m [1m[94m|[0m     pub fn len(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m243[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m248[0m [1m[94m|[0m     pub fn chrom(&self) -> ChromIdx {
    [1m[94m|[0m            [1m[33m^^^^^[0m

[1m[33mwarning[0m[1m: associated function `with_scale` is never used[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:275:12
    [1m[94m|[0m
[1m[94m266[0m [1m[94m|[0m impl PositionMap {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94massociated function in this implementation[0m
[1m[94m...[0m
[1m[94m275[0m [1m[94m|[0m     pub fn with_scale(scale_factor: f64) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:306:12
    [1m[94m|[0m
[1m[94m302[0m [1m[94m|[0m impl MarkerMap {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m306[0m [1m[94m|[0m     pub fn create(markers: &Markers, gen_map: &GeneticMap) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m325[0m [1m[94m|[0m     pub fn from_gen_map_with_min_dist(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m362[0m [1m[94m|[0m     pub fn from_gen_map(markers: &Markers, gen_map: &GeneticMap) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m417[0m [1m[94m|[0m     fn mean_single_base_gen_dist(markers: &Markers, gen_map: &GeneticMap) -> f64 {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m445[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m450[0m [1m[94m|[0m     pub fn gen_pos(&self, index: usize) -> f64 {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m460[0m [1m[94m|[0m     pub fn gen_positions(&self) -> &[f64] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m465[0m [1m[94m|[0m     pub fn gen_distances(&self) -> &[f32] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/haplotype.rs:119:12
    [1m[94m|[0m
[1m[94m117[0m [1m[94m|[0m impl Samples {
    [1m[94m|[0m [1m[94m------------[0m [1m[94massociated items in this implementation[0m
[1m[94m118[0m [1m[94m|[0m     /// Create an empty sample collection
[1m[94m119[0m [1m[94m|[0m     pub fn new() -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m141[0m [1m[94m|[0m     pub fn from_ids_with_ploidy(ids: Vec<String>, is_diploid: Vec<bool>) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m163[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m176[0m [1m[94m|[0m     pub fn id(&self, idx: SampleIdx) -> &str {
    [1m[94m|[0m            [1m[33m^^[0m
[1m[94m...[0m
[1m[94m186[0m [1m[94m|[0m     pub fn is_diploid(&self, idx: SampleIdx) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m191[0m [1m[94m|[0m     pub fn push(&mut self, id: String, diploid: bool) {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m205[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = SampleIdx> {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m210[0m [1m[94m|[0m     pub fn hap_iter(&self) -> impl Iterator<Item = HapIdx> + '_ {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m221[0m [1m[94m|[0m     pub fn combine(first: &Samples, second: &Samples) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `is_missing`, `is_empty`, and `complement` are never used[0m
   [1m[94m--> [0msrc/data/marker.rs:82:12
    [1m[94m|[0m
[1m[94m 52[0m [1m[94m|[0m impl Allele {
    [1m[94m|[0m [1m[94m-----------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 82[0m [1m[94m|[0m     pub fn is_missing(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 96[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m101[0m [1m[94m|[0m     pub fn complement(&self) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `allele`, `span`, `overlaps`, and `has_end_value` are never used[0m
   [1m[94m--> [0msrc/data/marker.rs:179:12
    [1m[94m|[0m
[1m[94m144[0m [1m[94m|[0m impl Marker {
    [1m[94m|[0m [1m[94m-----------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m179[0m [1m[94m|[0m     pub fn allele(&self, idx: usize) -> Option<&Allele> {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m217[0m [1m[94m|[0m     pub fn span(&self) -> u32 {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m222[0m [1m[94m|[0m     pub fn overlaps(&self, start: u32, end: u32) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m227[0m [1m[94m|[0m     pub fn has_end_value(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `from_vec`, `is_empty`, and `iter` are never used[0m
   [1m[94m--> [0msrc/data/marker.rs:461:12
    [1m[94m|[0m
[1m[94m454[0m [1m[94m|[0m impl Markers {
    [1m[94m|[0m [1m[94m------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m461[0m [1m[94m|[0m     pub fn from_vec(markers: Vec<Marker>, chrom_names: Vec<Arc<str>>) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m474[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m512[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = &Marker> {
    [1m[94m|[0m            [1m[33m^^^^[0m

[1m[33mwarning[0m[1m: methods `size_bytes`, `is_biallelic`, and `iter` are never used[0m
   [1m[94m--> [0msrc/data/storage/mod.rs:81:12
    [1m[94m|[0m
[1m[94m 40[0m [1m[94m|[0m impl GenotypeColumn {
    [1m[94m|[0m [1m[94m-------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 81[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m126[0m [1m[94m|[0m     pub fn is_biallelic(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m135[0m [1m[94m|[0m     pub fn iter(&self) -> Box<dyn Iterator<Item = u8> + '_> {
    [1m[94m|[0m            [1m[33m^^^^[0m

[1m[33mwarning[0m[1m: field `first_allele` is never read[0m
  [1m[94m--> [0msrc/data/storage/coded_steps.rs:36:5
   [1m[94m|[0m
[1m[94m24[0m [1m[94m|[0m pub struct CodedStep {
   [1m[94m|[0m            [1m[94m---------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m36[0m [1m[94m|[0m     first_allele: Vec<u8>,
   [1m[94m|[0m     [1m[33m^^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `CodedStep` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `allele`, `first_allele`, `pattern_alleles`, and `haps_with_pattern` are never used[0m
   [1m[94m--> [0msrc/data/storage/coded_steps.rs:118:12
    [1m[94m|[0m
[1m[94m 39[0m [1m[94m|[0m impl CodedStep {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m118[0m [1m[94m|[0m     pub fn allele(&self, pattern: u16, marker_offset: usize) -> u8 {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m129[0m [1m[94m|[0m     pub fn first_allele(&self, pattern: u16) -> u8 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m134[0m [1m[94m|[0m     pub fn pattern_alleles(&self, pattern: u16) -> &[u8] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m139[0m [1m[94m|[0m     pub fn haps_with_pattern(&self, pattern: u16) -> Vec<HapIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `from_gen_positions`, `step`, `total_patterns`, and `avg_compression_ratio` are never used[0m
   [1m[94m--> [0msrc/data/storage/coded_steps.rs:190:12
    [1m[94m|[0m
[1m[94m169[0m [1m[94m|[0m impl RefPanelCoded {
    [1m[94m|[0m [1m[94m------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m190[0m [1m[94m|[0m     pub fn from_gen_positions(gt: &GenotypeMatrix, gen_positions: &[f64], step_cm: f64) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m201[0m [1m[94m|[0m     pub fn step(&self, idx: usize) -> &CodedStep {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m224[0m [1m[94m|[0m     pub fn total_patterns(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m229[0m [1m[94m|[0m     pub fn avg_compression_ratio(&self) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: method `reset` is never used[0m
   [1m[94m--> [0msrc/data/storage/coded_steps.rs:367:12
    [1m[94m|[0m
[1m[94m283[0m [1m[94m|[0m impl CodedPbwt {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m367[0m [1m[94m|[0m     pub fn reset(&mut self) {
    [1m[94m|[0m            [1m[33m^^^^^[0m

[1m[33mwarning[0m[1m: methods `size_bytes`, `raw_bits`, and `raw_u64s` are never used[0m
   [1m[94m--> [0msrc/data/storage/dense.rs:127:12
    [1m[94m|[0m
[1m[94m 25[0m [1m[94m|[0m impl DenseColumn {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m127[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m133[0m [1m[94m|[0m     pub fn raw_bits(&self) -> &BitSlice<u64, Lsb0> {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m138[0m [1m[94m|[0m     pub fn raw_u64s(&self) -> &[u64] {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `compression_ratio`, `is_biallelic`, `iter_marker`, `haplotypes_with_pattern`, and `size_bytes` are never used[0m
   [1m[94m--> [0msrc/data/storage/dictionary.rs:30:12
    [1m[94m|[0m
[1m[94m 28[0m [1m[94m|[0m impl DictionaryColumn {
    [1m[94m|[0m [1m[94m---------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m 29[0m [1m[94m|[0m     /// Create a new dictionary column from patterns and mapping
[1m[94m 30[0m [1m[94m|[0m     pub fn new(
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m127[0m [1m[94m|[0m     pub fn compression_ratio(&self) -> f64 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m132[0m [1m[94m|[0m     pub fn is_biallelic(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m148[0m [1m[94m|[0m     pub fn iter_marker(&self, marker_offset: usize) -> impl Iterator<Item = u8> + '_ {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m158[0m [1m[94m|[0m     pub fn haplotypes_with_pattern(&self, pattern_idx: u16) -> Vec<HapIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m168[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/storage/matrix.rs:51:12
    [1m[94m|[0m
[1m[94m 32[0m [1m[94m|[0m impl GenotypeMatrix {
    [1m[94m|[0m [1m[94m-------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m 51[0m [1m[94m|[0m     pub fn empty(samples: Arc<Samples>) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^[0m
[1m[94m...[0m
[1m[94m 77[0m [1m[94m|[0m     pub fn is_phased(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 82[0m [1m[94m|[0m     pub fn is_reversed(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 97[0m [1m[94m|[0m     pub fn samples(&self) -> &Samples {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m136[0m [1m[94m|[0m     pub fn restrict_markers(&self, indices: &[usize]) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m153[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = (MarkerIdx, &Marker, &GenotypeColumn)> {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m161[0m [1m[94m|[0m     pub fn marker_indices(&self) -> impl Iterator<Item = MarkerIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m166[0m [1m[94m|[0m     pub fn haplotype_indices(&self) -> impl Iterator<Item = HapIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m171[0m [1m[94m|[0m     pub fn haplotype(&self, hap: HapIdx) -> Vec<u8> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m176[0m [1m[94m|[0m     pub fn alleles_at_marker(&self, marker: MarkerIdx) -> Vec<u8> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m184[0m [1m[94m|[0m     pub fn set_phased(&mut self, phased: bool) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m189[0m [1m[94m|[0m     pub fn set_reversed(&mut self, reversed: bool) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m194[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m200[0m [1m[94m|[0m     pub fn column_mut(&mut self, idx: MarkerIdx) -> &mut GenotypeColumn {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m205[0m [1m[94m|[0m     pub fn set_column(&mut self, idx: MarkerIdx, column: GenotypeColumn) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m210[0m [1m[94m|[0m     pub fn push(&mut self, marker: Marker, column: GenotypeColumn) {
    [1m[94m|[0m            [1m[33m^^^^[0m

[1m[33mwarning[0m[1m: methods `marker_alleles_mut`, `swap_range`, `copy_from`, and `raw_alleles` are never used[0m
   [1m[94m--> [0msrc/data/storage/mutable.rs:72:12
    [1m[94m|[0m
[1m[94m 20[0m [1m[94m|[0m impl MutableGenotypes {
    [1m[94m|[0m [1m[94m---------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 72[0m [1m[94m|[0m     pub fn marker_alleles_mut(&mut self, marker: usize) -> &mut [u8] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 91[0m [1m[94m|[0m     pub fn swap_range(&mut self, markers: &[usize], hap1: HapIdx, hap2: HapIdx) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m100[0m [1m[94m|[0m     pub fn copy_from(&mut self, other: &MutableGenotypes) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m109[0m [1m[94m|[0m     pub fn raw_alleles(&self) -> &[Vec<u8>] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `is_carrier`, `maf`, `size_bytes`, and `iter` are never used[0m
   [1m[94m--> [0msrc/data/storage/sparse.rs:73:12
    [1m[94m|[0m
[1m[94m 22[0m [1m[94m|[0m impl SparseColumn {
    [1m[94m|[0m [1m[94m-----------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 73[0m [1m[94m|[0m     pub fn is_carrier(&self, hap: HapIdx) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 97[0m [1m[94m|[0m     pub fn maf(&self) -> f64 {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m107[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m113[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = u8> + '_ {
    [1m[94m|[0m            [1m[33m^^^^[0m

[1m[33mwarning[0m[1m: field `n_haplotypes` is never read[0m
   [1m[94m--> [0msrc/data/storage/sparse.rs:130:5
    [1m[94m|[0m
[1m[94m125[0m [1m[94m|[0m pub struct SparseMultiAllelic {
    [1m[94m|[0m            [1m[94m------------------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m130[0m [1m[94m|[0m     n_haplotypes: u32,
    [1m[94m|[0m     [1m[33m^^^^^^^^^^^^[0m
    [1m[94m|[0m
    [1m[94m= [0m[1mnote[0m: `SparseMultiAllelic` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `n_haplotypes`, `n_entries`, and `size_bytes` are never used[0m
   [1m[94m--> [0msrc/data/storage/sparse.rs:153:12
    [1m[94m|[0m
[1m[94m133[0m [1m[94m|[0m impl SparseMultiAllelic {
    [1m[94m|[0m [1m[94m-----------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m153[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m158[0m [1m[94m|[0m     pub fn n_entries(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m163[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: method `markers` is never used[0m
  [1m[94m--> [0msrc/data/storage/view.rs:58:12
   [1m[94m|[0m
[1m[94m24[0m [1m[94m|[0m impl<'a> GenotypeView<'a> {
   [1m[94m|[0m [1m[94m-------------------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m58[0m [1m[94m|[0m     pub fn markers(&self) -> &Markers {
   [1m[94m|[0m            [1m[33m^^^^^^^[0m

[1m[33mwarning[0m[1m: fields `buffer_cm` and `max_markers` are never read[0m
  [1m[94m--> [0msrc/io/streaming.rs:35:9
   [1m[94m|[0m
[1m[94m29[0m [1m[94m|[0m pub struct StreamingConfig {
   [1m[94m|[0m            [1m[94m---------------[0m [1m[94mfields in this struct[0m
[1m[94m...[0m
[1m[94m35[0m [1m[94m|[0m     pub buffer_cm: f32,
   [1m[94m|[0m         [1m[33m^^^^^^^^^[0m
[1m[94m36[0m [1m[94m|[0m     /// Maximum markers per window
[1m[94m37[0m [1m[94m|[0m     pub max_markers: usize,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `StreamingConfig` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: fields `ref_gt`, `gen_map`, and `indices` are never read[0m
  [1m[94m--> [0msrc/io/window.rs:17:9
   [1m[94m|[0m
[1m[94m12[0m [1m[94m|[0m pub struct Window {
   [1m[94m|[0m            [1m[94m------[0m [1m[94mfields in this struct[0m
[1m[94m...[0m
[1m[94m17[0m [1m[94m|[0m     pub ref_gt: Option<GenotypeMatrix>,
   [1m[94m|[0m         [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m20[0m [1m[94m|[0m     pub gen_map: GeneticMap,
   [1m[94m|[0m         [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m23[0m [1m[94m|[0m     pub indices: WindowIndices,
   [1m[94m|[0m         [1m[33m^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `Window` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: multiple fields are never read[0m
  [1m[94m--> [0msrc/io/window.rs:33:9
   [1m[94m|[0m
[1m[94m31[0m [1m[94m|[0m pub struct WindowIndices {
   [1m[94m|[0m            [1m[94m-------------[0m [1m[94mfields in this struct[0m
[1m[94m32[0m [1m[94m|[0m     /// Start marker index (inclusive) in the full dataset
[1m[94m33[0m [1m[94m|[0m     pub start: usize,
   [1m[94m|[0m         [1m[33m^^^^^[0m
[1m[94m34[0m [1m[94m|[0m     /// End marker index (exclusive) in the full dataset
[1m[94m35[0m [1m[94m|[0m     pub end: usize,
   [1m[94m|[0m         [1m[33m^^^[0m
[1m[94m36[0m [1m[94m|[0m     /// Previous splice point (where output starts)
[1m[94m37[0m [1m[94m|[0m     pub prev_splice: usize,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^[0m
[1m[94m38[0m [1m[94m|[0m     /// Next splice point (where output ends)
[1m[94m39[0m [1m[94m|[0m     pub next_splice: usize,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^[0m
[1m[94m40[0m [1m[94m|[0m     /// Overlap start (where next window's data begins)
[1m[94m41[0m [1m[94m|[0m     pub overlap_start: usize,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^^[0m
[1m[94m42[0m [1m[94m|[0m     /// Number of target markers
[1m[94m43[0m [1m[94m|[0m     pub n_targ_markers: usize,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m44[0m [1m[94m|[0m     /// Number of reference markers (if imputing)
[1m[94m45[0m [1m[94m|[0m     pub n_ref_markers: usize,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `WindowIndices` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `n_samples`, `n_haplotypes`, `has_ref`, and `gen_dist` are never used[0m
  [1m[94m--> [0msrc/io/window.rs:84:12
   [1m[94m|[0m
[1m[94m60[0m [1m[94m|[0m impl Window {
   [1m[94m|[0m [1m[94m-----------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m84[0m [1m[94m|[0m     pub fn n_samples(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m89[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m94[0m [1m[94m|[0m     pub fn has_ref(&self) -> bool {
   [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m99[0m [1m[94m|[0m     pub fn gen_dist(&self, m1: usize, m2: usize) -> f64 {
   [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: field `buffer_cm` is never read[0m
   [1m[94m--> [0msrc/io/window.rs:115:5
    [1m[94m|[0m
[1m[94m107[0m [1m[94m|[0m pub struct WindowBuilder {
    [1m[94m|[0m            [1m[94m-------------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m115[0m [1m[94m|[0m     buffer_cm: f32,
    [1m[94m|[0m     [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `max_markers` and `buffer_cm` are never used[0m
   [1m[94m--> [0msrc/io/window.rs:142:12
    [1m[94m|[0m
[1m[94m118[0m [1m[94m|[0m impl WindowBuilder {
    [1m[94m|[0m [1m[94m------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m142[0m [1m[94m|[0m     pub fn max_markers(mut self, n: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m148[0m [1m[94m|[0m     pub fn buffer_cm(mut self, cm: f32) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated functions `fwd_update_alleles` and `bwd_update_alleles` are never used[0m
   [1m[94m--> [0msrc/model/hmm.rs:106:12
    [1m[94m|[0m
[1m[94m 34[0m [1m[94m|[0m impl HmmUpdater {
    [1m[94m|[0m [1m[94m---------------[0m [1m[94massociated functions in this implementation[0m
[1m[94m...[0m
[1m[94m106[0m [1m[94m|[0m     pub fn fwd_update_alleles(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m131[0m [1m[94m|[0m     pub fn bwd_update_alleles(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated function `from_gen_dists` is never used[0m
   [1m[94m--> [0msrc/model/hmm.rs:194:12
    [1m[94m|[0m
[1m[94m171[0m [1m[94m|[0m impl<'a> LiStephensHmm<'a> {
    [1m[94m|[0m [1m[94m--------------------------[0m [1m[94massociated function in this implementation[0m
[1m[94m...[0m
[1m[94m194[0m [1m[94m|[0m     pub fn from_gen_dists(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: field `other_sample` is never read[0m
  [1m[94m--> [0msrc/model/ibs2.rs:28:9
   [1m[94m|[0m
[1m[94m26[0m [1m[94m|[0m pub struct Ibs2Segment {
   [1m[94m|[0m            [1m[94m-----------[0m [1m[94mfield in this struct[0m
[1m[94m27[0m [1m[94m|[0m     /// The other sample in the IBS2 relationship
[1m[94m28[0m [1m[94m|[0m     pub other_sample: SampleIdx,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `Ibs2Segment` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: fields `n_markers` and `sample_segs` are never read[0m
  [1m[94m--> [0msrc/model/ibs2.rs:58:5
   [1m[94m|[0m
[1m[94m56[0m [1m[94m|[0m pub struct Ibs2 {
   [1m[94m|[0m            [1m[94m----[0m [1m[94mfields in this struct[0m
[1m[94m57[0m [1m[94m|[0m     /// Number of markers
[1m[94m58[0m [1m[94m|[0m     n_markers: usize,
   [1m[94m|[0m     [1m[33m^^^^^^^^^[0m
[1m[94m59[0m [1m[94m|[0m     /// IBS2 segments for each sample: sample_segs[sample_idx] = Vec<Ibs2Segment>
[1m[94m60[0m [1m[94m|[0m     sample_segs: Vec<Vec<Ibs2Segment>>,
   [1m[94m|[0m     [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/model/ibs2.rs:70:12
    [1m[94m|[0m
[1m[94m 63[0m [1m[94m|[0m impl Ibs2 {
    [1m[94m|[0m [1m[94m---------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m 70[0m [1m[94m|[0m     pub fn new(gt: &GenotypeMatrix, gen_map: &GeneticMap, maf: &[f32]) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m 92[0m [1m[94m|[0m     fn build_sample_segments(
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m118[0m [1m[94m|[0m     fn merge_segments(segments: Vec<Ibs2Segment>, gen_map: &GeneticMap) -> Vec<Ibs2Segment> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m147[0m [1m[94m|[0m     fn gap_cm(prev: &Ibs2Segment, next: &Ibs2Segment, gen_map: &GeneticMap) -> f64 {
    [1m[94m|[0m        [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m153[0m [1m[94m|[0m     fn extend_segments(
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m182[0m [1m[94m|[0m     fn filter_by_length(segments: Vec<Ibs2Segment>, gen_map: &GeneticMap) -> Vec<Ibs2Segment> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m195[0m [1m[94m|[0m     fn is_ibs2_at(gt: &GenotypeMatrix, marker: usize, s1: SampleIdx, s2: SampleIdx) -> bool {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m212[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m217[0m [1m[94m|[0m     pub fn n_samples(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m222[0m [1m[94m|[0m     pub fn n_segments(&self, sample: SampleIdx) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m230[0m [1m[94m|[0m     pub fn are_ibs2(&self, sample: SampleIdx, other: SampleIdx, marker: usize) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m250[0m [1m[94m|[0m     pub fn are_ibs2_in_interval(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m279[0m [1m[94m|[0m     pub fn segments(&self, sample: SampleIdx) -> &[Ibs2Segment] {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m287[0m [1m[94m|[0m     pub fn ibs2_samples_at(&self, sample: SampleIdx, marker: usize) -> Vec<SampleIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: fields `ne` and `use_em` are never read[0m
  [1m[94m--> [0msrc/model/parameters.rs:14:9
   [1m[94m|[0m
[1m[94m11[0m [1m[94m|[0m pub struct ModelParams {
   [1m[94m|[0m            [1m[94m-----------[0m [1m[94mfields in this struct[0m
[1m[94m...[0m
[1m[94m14[0m [1m[94m|[0m     pub ne: u64,
   [1m[94m|[0m         [1m[33m^^[0m
[1m[94m...[0m
[1m[94m44[0m [1m[94m|[0m     pub use_em: bool,
   [1m[94m|[0m         [1m[33m^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `ModelParams` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `switch_prob`, `no_switch_prob`, `set_ne`, and `set_n_haps` are never used[0m
   [1m[94m--> [0msrc/model/parameters.rs:177:12
    [1m[94m|[0m
[1m[94m 47[0m [1m[94m|[0m impl ModelParams {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m177[0m [1m[94m|[0m     pub fn switch_prob(&self, gen_dist_cm: f64) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m182[0m [1m[94m|[0m     pub fn no_switch_prob(&self, gen_dist_cm: f64) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m227[0m [1m[94m|[0m     pub fn set_ne(&mut self, ne: u64) {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m240[0m [1m[94m|[0m     pub fn set_n_haps(&mut self, n_haps: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: method `sum_switch_probs` is never used[0m
   [1m[94m--> [0msrc/model/parameters.rs:307:12
    [1m[94m|[0m
[1m[94m276[0m [1m[94m|[0m impl ParamEstimates {
    [1m[94m|[0m [1m[94m-------------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m307[0m [1m[94m|[0m     pub fn sum_switch_probs(&self) -> f64 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `n_haps` and `update_with` are never used[0m
  [1m[94m--> [0msrc/model/pbwt.rs:46:12
   [1m[94m|[0m
[1m[94m32[0m [1m[94m|[0m impl PbwtUpdater {
   [1m[94m|[0m [1m[94m----------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m46[0m [1m[94m|[0m     pub fn n_haps(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m87[0m [1m[94m|[0m     pub fn update_with<F>(&mut self, get_allele: F, n_alleles: usize, prefix: &mut [u32])
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: method `n_haps` is never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:156:12
    [1m[94m|[0m
[1m[94m143[0m [1m[94m|[0m impl PbwtDivUpdater {
    [1m[94m|[0m [1m[94m-------------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m156[0m [1m[94m|[0m     pub fn n_haps(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: field `bwd_updater` is never read[0m
   [1m[94m--> [0msrc/model/pbwt.rs:457:5
    [1m[94m|[0m
[1m[94m441[0m [1m[94m|[0m pub struct PbwtIbs {
    [1m[94m|[0m            [1m[94m-------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m457[0m [1m[94m|[0m     bwd_updater: PbwtDivUpdater,
    [1m[94m|[0m     [1m[33m^^^^^^^^^^^[0m
    [1m[94m|[0m
    [1m[94m= [0m[1mnote[0m: `PbwtIbs` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `bwd_update`, `find_position`, `select_ibs_hap`, `select_states_for_external_target`, and `find_allele_region` are never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:499:12
    [1m[94m|[0m
[1m[94m460[0m [1m[94m|[0m impl PbwtIbs {
    [1m[94m|[0m [1m[94m------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m499[0m [1m[94m|[0m     pub fn bwd_update(&mut self, alleles: &[u8], n_alleles: usize, marker: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m530[0m [1m[94m|[0m     pub fn find_position(&self, hap: HapIdx, use_backward: bool) -> Option<usize> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m627[0m [1m[94m|[0m     pub fn select_ibs_hap(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m647[0m [1m[94m|[0m     pub fn select_states_for_external_target(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m696[0m [1m[94m|[0m     pub fn find_allele_region(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: fields `ref_haps` and `switch_probs` are never read[0m
  [1m[94m--> [0msrc/utils/workspace.rs:36:9
   [1m[94m|[0m
[1m[94m16[0m [1m[94m|[0m pub struct Workspace {
   [1m[94m|[0m            [1m[94m---------[0m [1m[94mfields in this struct[0m
[1m[94m...[0m
[1m[94m36[0m [1m[94m|[0m     pub ref_haps: Vec<HapIdx>,
   [1m[94m|[0m         [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m42[0m [1m[94m|[0m     pub switch_probs: Vec<f32>,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `Workspace` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `clear`, `reset_pbwt`, `init_fwd_uniform`, and `init_bwd_ones` are never used[0m
   [1m[94m--> [0msrc/utils/workspace.rs:98:12
    [1m[94m|[0m
[1m[94m 51[0m [1m[94m|[0m impl Workspace {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 98[0m [1m[94m|[0m     pub fn clear(&mut self) {
    [1m[94m|[0m            [1m[33m^^^^^[0m
[1m[94m...[0m
[1m[94m111[0m [1m[94m|[0m     pub fn reset_pbwt(&mut self, n_haps: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m123[0m [1m[94m|[0m     pub fn init_fwd_uniform(&mut self, n_states: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m131[0m [1m[94m|[0m     pub fn init_bwd_ones(&mut self, n_states: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m: `reagle` (bin "reagle" test) generated 99 warnings (57 duplicates) (run `cargo fix --bin "reagle" -p reagle --tests` to apply 1 suggestion)
[1m[92m    Finished[0m `dev` profile [unoptimized + debuginfo] target(s) in 2.83s
[1m[92m   Compiling[0m aho-corasick v1.1.4
[1m[92m   Compiling[0m encoding_rs v0.8.35
[1m[92m   Compiling[0m grep-matcher v0.1.8
[1m[92m   Compiling[0m memmap2 v0.9.9
[1m[92m   Compiling[0m serde_json v1.0.148
[1m[92m   Compiling[0m regex-automata v0.4.13
[1m[92m   Compiling[0m encoding_rs_io v0.1.7
[1m[92m   Compiling[0m bstr v1.12.1
[1m[92m   Compiling[0m grep-searcher v0.1.16
[1m[92m   Compiling[0m globset v0.4.18
[1m[92m   Compiling[0m grep-regex v0.1.14
[1m[92m   Compiling[0m grep-printer v0.2.2
[1m[92m   Compiling[0m grep-cli v0.1.12
[1m[92m   Compiling[0m grep v0.3.2
[1m[92m   Compiling[0m reagle v0.1.0 (/home/runner/work/reagle/reagle/Rust)
[1m[33mwarning[0m[1m: unused imports: `CodedPbwt`, `CodedStep`, `RefPanelCoded`, and `compute_step_starts`[0m
  [1m[94m--> [0msrc/data/storage/mod.rs:14:23
   [1m[94m|[0m
[1m[94m14[0m [1m[94m|[0m pub use coded_steps::{CodedStep, RefPanelCoded, CodedPbwt, compute_step_starts};
   [1m[94m|[0m                       [1m[33m^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

[1m[33mwarning[0m[1m: unused import: `genetic_map::GeneticMap`[0m
  [1m[94m--> [0msrc/data/mod.rs:19:9
   [1m[94m|[0m
[1m[94m19[0m [1m[94m|[0m pub use genetic_map::GeneticMap;
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused import: `Samples`[0m
  [1m[94m--> [0msrc/data/mod.rs:20:40
   [1m[94m|[0m
[1m[94m20[0m [1m[94m|[0m pub use haplotype::{HapIdx, SampleIdx, Samples};
   [1m[94m|[0m                                        [1m[33m^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `Allele`, `Marker`, and `Markers`[0m
  [1m[94m--> [0msrc/data/mod.rs:21:18
   [1m[94m|[0m
[1m[94m21[0m [1m[94m|[0m pub use marker::{Allele, Marker, MarkerIdx, Markers};
   [1m[94m|[0m                  [1m[33m^^^^^^[0m  [1m[33m^^^^^^[0m             [1m[33m^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `DenseColumn`, `DictionaryColumn`, `GenotypeColumn`, `GenotypeMatrix`, `GenotypeView`, `MutableGenotypes`, and `SparseColumn`[0m
  [1m[94m--> [0msrc/data/mod.rs:23:5
   [1m[94m|[0m
[1m[94m23[0m [1m[94m|[0m     DenseColumn, DictionaryColumn, GenotypeColumn, GenotypeMatrix, GenotypeView, MutableGenotypes,
   [1m[94m|[0m     [1m[33m^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m24[0m [1m[94m|[0m     SparseColumn,
   [1m[94m|[0m     [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `StreamWindow`, `StreamingConfig`, and `StreamingVcfReader`[0m
  [1m[94m--> [0msrc/io/mod.rs:10:21
   [1m[94m|[0m
[1m[94m10[0m [1m[94m|[0m pub use streaming::{StreamingVcfReader, StreamingConfig, StreamWindow};
   [1m[94m|[0m                     [1m[33m^^^^^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `ImputationQuality`, `MarkerImputationStats`, and `VcfWriter`[0m
  [1m[94m--> [0msrc/io/mod.rs:11:26
   [1m[94m|[0m
[1m[94m11[0m [1m[94m|[0m pub use vcf::{VcfReader, VcfWriter, ImputationQuality, MarkerImputationStats};
   [1m[94m|[0m                          [1m[33m^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `SlidingWindowIterator`, `WindowBuilder`, and `Window`[0m
  [1m[94m--> [0msrc/io/mod.rs:12:18
   [1m[94m|[0m
[1m[94m12[0m [1m[94m|[0m pub use window::{Window, WindowBuilder, SlidingWindowIterator};
   [1m[94m|[0m                  [1m[33m^^^^^^[0m  [1m[33m^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `HmmResult` and `LiStephensHmm`[0m
  [1m[94m--> [0msrc/model/mod.rs:16:15
   [1m[94m|[0m
[1m[94m16[0m [1m[94m|[0m pub use hmm::{LiStephensHmm, HmmResult};
   [1m[94m|[0m               [1m[33m^^^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `Ibs2Segment` and `Ibs2`[0m
  [1m[94m--> [0msrc/model/mod.rs:17:16
   [1m[94m|[0m
[1m[94m17[0m [1m[94m|[0m pub use ibs2::{Ibs2, Ibs2Segment};
   [1m[94m|[0m                [1m[33m^^^^[0m  [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `CodedStepsConfig`, `CodedSteps`, and `ImpStates`[0m
  [1m[94m--> [0msrc/model/mod.rs:18:22
   [1m[94m|[0m
[1m[94m18[0m [1m[94m|[0m pub use imp_states::{ImpStates, CodedSteps, CodedStepsConfig};
   [1m[94m|[0m                      [1m[33m^^^^^^^^^[0m  [1m[33m^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: unused imports: `PbwtDivUpdater` and `PbwtUpdater`[0m
  [1m[94m--> [0msrc/model/mod.rs:20:16
   [1m[94m|[0m
[1m[94m20[0m [1m[94m|[0m pub use pbwt::{PbwtUpdater, PbwtDivUpdater};
   [1m[94m|[0m                [1m[33m^^^^^^^^^^^[0m  [1m[33m^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: method `err_rate` is never used[0m
   [1m[94m--> [0msrc/config.rs:200:12
    [1m[94m|[0m
[1m[94m131[0m [1m[94m|[0m impl Config {
    [1m[94m|[0m [1m[94m-----------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m200[0m [1m[94m|[0m     pub fn err_rate(&self, n_haps: usize) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
    [1m[94m|[0m
    [1m[94m= [0m[1mnote[0m: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

[1m[33mwarning[0m[1m: constant `MIN_GEN_DIST` is never used[0m
  [1m[94m--> [0msrc/data/genetic_map.rs:23:11
   [1m[94m|[0m
[1m[94m23[0m [1m[94m|[0m pub const MIN_GEN_DIST: f64 = 1e-8;
   [1m[94m|[0m           [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `position_map`, `len`, `is_empty`, and `chrom` are never used[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:66:12
    [1m[94m|[0m
[1m[94m 40[0m [1m[94m|[0m impl GeneticMap {
    [1m[94m|[0m [1m[94m---------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m 66[0m [1m[94m|[0m     pub fn position_map(scale_factor: f64) -> PositionMap {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m238[0m [1m[94m|[0m     pub fn len(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m243[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m248[0m [1m[94m|[0m     pub fn chrom(&self) -> ChromIdx {
    [1m[94m|[0m            [1m[33m^^^^^[0m

[1m[33mwarning[0m[1m: associated function `with_scale` is never used[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:275:12
    [1m[94m|[0m
[1m[94m266[0m [1m[94m|[0m impl PositionMap {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94massociated function in this implementation[0m
[1m[94m...[0m
[1m[94m275[0m [1m[94m|[0m     pub fn with_scale(scale_factor: f64) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:306:12
    [1m[94m|[0m
[1m[94m302[0m [1m[94m|[0m impl MarkerMap {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m306[0m [1m[94m|[0m     pub fn create(markers: &Markers, gen_map: &GeneticMap) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m325[0m [1m[94m|[0m     pub fn from_gen_map_with_min_dist(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m362[0m [1m[94m|[0m     pub fn from_gen_map(markers: &Markers, gen_map: &GeneticMap) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m417[0m [1m[94m|[0m     fn mean_single_base_gen_dist(markers: &Markers, gen_map: &GeneticMap) -> f64 {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m445[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m450[0m [1m[94m|[0m     pub fn gen_pos(&self, index: usize) -> f64 {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m460[0m [1m[94m|[0m     pub fn gen_positions(&self) -> &[f64] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m465[0m [1m[94m|[0m     pub fn gen_distances(&self) -> &[f32] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: method `insert` is never used[0m
   [1m[94m--> [0msrc/data/genetic_map.rs:557:12
    [1m[94m|[0m
[1m[94m534[0m [1m[94m|[0m impl GeneticMaps {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m557[0m [1m[94m|[0m     pub fn insert(&mut self, chrom: ChromIdx, map: GeneticMap) {
    [1m[94m|[0m            [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/haplotype.rs:119:12
    [1m[94m|[0m
[1m[94m117[0m [1m[94m|[0m impl Samples {
    [1m[94m|[0m [1m[94m------------[0m [1m[94massociated items in this implementation[0m
[1m[94m118[0m [1m[94m|[0m     /// Create an empty sample collection
[1m[94m119[0m [1m[94m|[0m     pub fn new() -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m141[0m [1m[94m|[0m     pub fn from_ids_with_ploidy(ids: Vec<String>, is_diploid: Vec<bool>) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m163[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m176[0m [1m[94m|[0m     pub fn id(&self, idx: SampleIdx) -> &str {
    [1m[94m|[0m            [1m[33m^^[0m
[1m[94m...[0m
[1m[94m186[0m [1m[94m|[0m     pub fn is_diploid(&self, idx: SampleIdx) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m191[0m [1m[94m|[0m     pub fn push(&mut self, id: String, diploid: bool) {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m205[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = SampleIdx> {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m210[0m [1m[94m|[0m     pub fn hap_iter(&self) -> impl Iterator<Item = HapIdx> + '_ {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m221[0m [1m[94m|[0m     pub fn combine(first: &Samples, second: &Samples) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `is_missing`, `is_empty`, and `complement` are never used[0m
   [1m[94m--> [0msrc/data/marker.rs:82:12
    [1m[94m|[0m
[1m[94m 52[0m [1m[94m|[0m impl Allele {
    [1m[94m|[0m [1m[94m-----------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 82[0m [1m[94m|[0m     pub fn is_missing(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 96[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m101[0m [1m[94m|[0m     pub fn complement(&self) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: field `end` is never read[0m
   [1m[94m--> [0msrc/data/marker.rs:135:9
    [1m[94m|[0m
[1m[94m128[0m [1m[94m|[0m pub struct Marker {
    [1m[94m|[0m            [1m[94m------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m135[0m [1m[94m|[0m     pub end: u32,
    [1m[94m|[0m         [1m[33m^^^[0m
    [1m[94m|[0m
    [1m[94m= [0m[1mnote[0m: `Marker` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `allele`, `span`, `overlaps`, and `has_end_value` are never used[0m
   [1m[94m--> [0msrc/data/marker.rs:179:12
    [1m[94m|[0m
[1m[94m144[0m [1m[94m|[0m impl Marker {
    [1m[94m|[0m [1m[94m-----------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m179[0m [1m[94m|[0m     pub fn allele(&self, idx: usize) -> Option<&Allele> {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m217[0m [1m[94m|[0m     pub fn span(&self) -> u32 {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m222[0m [1m[94m|[0m     pub fn overlaps(&self, start: u32, end: u32) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m227[0m [1m[94m|[0m     pub fn has_end_value(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `AlleleMapping` is never constructed[0m
   [1m[94m--> [0msrc/data/marker.rs:236:12
    [1m[94m|[0m
[1m[94m236[0m [1m[94m|[0m pub struct AlleleMapping {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `identity`, `no_match`, `map_allele`, and `is_valid` are never used[0m
   [1m[94m--> [0msrc/data/marker.rs:247:12
    [1m[94m|[0m
[1m[94m245[0m [1m[94m|[0m impl AlleleMapping {
    [1m[94m|[0m [1m[94m------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m246[0m [1m[94m|[0m     /// Create an identity mapping (no transformation needed)
[1m[94m247[0m [1m[94m|[0m     pub fn identity(n_alleles: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m256[0m [1m[94m|[0m     pub fn no_match(n_alleles: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m266[0m [1m[94m|[0m     pub fn map_allele(&self, targ_allele: u8) -> Option<u8> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m273[0m [1m[94m|[0m     pub fn is_valid(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `compute_allele_mapping` is never used[0m
   [1m[94m--> [0msrc/data/marker.rs:292:8
    [1m[94m|[0m
[1m[94m292[0m [1m[94m|[0m pub fn compute_allele_mapping(targ: &Marker, ref_marker: &Marker) -> Option<AlleleMapping> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `try_direct_match` is never used[0m
   [1m[94m--> [0msrc/data/marker.rs:319:4
    [1m[94m|[0m
[1m[94m319[0m [1m[94m|[0m fn try_direct_match(targ: &Marker, ref_marker: &Marker) -> Option<AlleleMapping> {
    [1m[94m|[0m    [1m[33m^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `try_strand_flip` is never used[0m
   [1m[94m--> [0msrc/data/marker.rs:362:4
    [1m[94m|[0m
[1m[94m362[0m [1m[94m|[0m fn try_strand_flip(targ: &Marker, ref_marker: &Marker) -> Option<AlleleMapping> {
    [1m[94m|[0m    [1m[33m^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `is_strand_ambiguous` is never used[0m
   [1m[94m--> [0msrc/data/marker.rs:405:8
    [1m[94m|[0m
[1m[94m405[0m [1m[94m|[0m pub fn is_strand_ambiguous(marker: &Marker) -> bool {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `from_vec`, `is_empty`, and `iter` are never used[0m
   [1m[94m--> [0msrc/data/marker.rs:461:12
    [1m[94m|[0m
[1m[94m454[0m [1m[94m|[0m impl Markers {
    [1m[94m|[0m [1m[94m------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m461[0m [1m[94m|[0m     pub fn from_vec(markers: Vec<Marker>, chrom_names: Vec<Arc<str>>) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m474[0m [1m[94m|[0m     pub fn is_empty(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m512[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = &Marker> {
    [1m[94m|[0m            [1m[33m^^^^[0m

[1m[33mwarning[0m[1m: variant `Dictionary` is never constructed[0m
  [1m[94m--> [0msrc/data/storage/mod.rs:37:5
   [1m[94m|[0m
[1m[94m26[0m [1m[94m|[0m pub enum GenotypeColumn {
   [1m[94m|[0m          [1m[94m--------------[0m [1m[94mvariant in this enum[0m
[1m[94m...[0m
[1m[94m37[0m [1m[94m|[0m     Dictionary(DictionaryColumn),
   [1m[94m|[0m     [1m[33m^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `GenotypeColumn` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `size_bytes`, `is_biallelic`, and `iter` are never used[0m
   [1m[94m--> [0msrc/data/storage/mod.rs:81:12
    [1m[94m|[0m
[1m[94m 40[0m [1m[94m|[0m impl GenotypeColumn {
    [1m[94m|[0m [1m[94m-------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 81[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m126[0m [1m[94m|[0m     pub fn is_biallelic(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m135[0m [1m[94m|[0m     pub fn iter(&self) -> Box<dyn Iterator<Item = u8> + '_> {
    [1m[94m|[0m            [1m[33m^^^^[0m

[1m[33mwarning[0m[1m: field `first_allele` is never read[0m
  [1m[94m--> [0msrc/data/storage/coded_steps.rs:36:5
   [1m[94m|[0m
[1m[94m24[0m [1m[94m|[0m pub struct CodedStep {
   [1m[94m|[0m            [1m[94m---------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m36[0m [1m[94m|[0m     first_allele: Vec<u8>,
   [1m[94m|[0m     [1m[33m^^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `CodedStep` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `allele`, `first_allele`, `pattern_alleles`, and `haps_with_pattern` are never used[0m
   [1m[94m--> [0msrc/data/storage/coded_steps.rs:118:12
    [1m[94m|[0m
[1m[94m 39[0m [1m[94m|[0m impl CodedStep {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m118[0m [1m[94m|[0m     pub fn allele(&self, pattern: u16, marker_offset: usize) -> u8 {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m129[0m [1m[94m|[0m     pub fn first_allele(&self, pattern: u16) -> u8 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m134[0m [1m[94m|[0m     pub fn pattern_alleles(&self, pattern: u16) -> &[u8] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m139[0m [1m[94m|[0m     pub fn haps_with_pattern(&self, pattern: u16) -> Vec<HapIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `from_gen_positions`, `step`, `total_patterns`, and `avg_compression_ratio` are never used[0m
   [1m[94m--> [0msrc/data/storage/coded_steps.rs:190:12
    [1m[94m|[0m
[1m[94m169[0m [1m[94m|[0m impl RefPanelCoded {
    [1m[94m|[0m [1m[94m------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m190[0m [1m[94m|[0m     pub fn from_gen_positions(gt: &GenotypeMatrix, gen_positions: &[f64], step_cm: f64) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m201[0m [1m[94m|[0m     pub fn step(&self, idx: usize) -> &CodedStep {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m224[0m [1m[94m|[0m     pub fn total_patterns(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m229[0m [1m[94m|[0m     pub fn avg_compression_ratio(&self) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: method `reset` is never used[0m
   [1m[94m--> [0msrc/data/storage/coded_steps.rs:367:12
    [1m[94m|[0m
[1m[94m283[0m [1m[94m|[0m impl CodedPbwt {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m367[0m [1m[94m|[0m     pub fn reset(&mut self) {
    [1m[94m|[0m            [1m[33m^^^^^[0m

[1m[33mwarning[0m[1m: methods `size_bytes`, `raw_bits`, and `raw_u64s` are never used[0m
   [1m[94m--> [0msrc/data/storage/dense.rs:127:12
    [1m[94m|[0m
[1m[94m 25[0m [1m[94m|[0m impl DenseColumn {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m127[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m133[0m [1m[94m|[0m     pub fn raw_bits(&self) -> &BitSlice<u64, Lsb0> {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m138[0m [1m[94m|[0m     pub fn raw_u64s(&self) -> &[u64] {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `compression_ratio`, `is_biallelic`, `iter_marker`, `haplotypes_with_pattern`, and `size_bytes` are never used[0m
   [1m[94m--> [0msrc/data/storage/dictionary.rs:30:12
    [1m[94m|[0m
[1m[94m 28[0m [1m[94m|[0m impl DictionaryColumn {
    [1m[94m|[0m [1m[94m---------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m 29[0m [1m[94m|[0m     /// Create a new dictionary column from patterns and mapping
[1m[94m 30[0m [1m[94m|[0m     pub fn new(
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m127[0m [1m[94m|[0m     pub fn compression_ratio(&self) -> f64 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m132[0m [1m[94m|[0m     pub fn is_biallelic(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m148[0m [1m[94m|[0m     pub fn iter_marker(&self, marker_offset: usize) -> impl Iterator<Item = u8> + '_ {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m158[0m [1m[94m|[0m     pub fn haplotypes_with_pattern(&self, pattern_idx: u16) -> Vec<HapIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m168[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/storage/matrix.rs:51:12
    [1m[94m|[0m
[1m[94m 32[0m [1m[94m|[0m impl GenotypeMatrix {
    [1m[94m|[0m [1m[94m-------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m 51[0m [1m[94m|[0m     pub fn empty(samples: Arc<Samples>) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^[0m
[1m[94m...[0m
[1m[94m 77[0m [1m[94m|[0m     pub fn is_phased(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 82[0m [1m[94m|[0m     pub fn is_reversed(&self) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 97[0m [1m[94m|[0m     pub fn samples(&self) -> &Samples {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m136[0m [1m[94m|[0m     pub fn restrict_markers(&self, indices: &[usize]) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m153[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = (MarkerIdx, &Marker, &GenotypeColumn)> {
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m161[0m [1m[94m|[0m     pub fn marker_indices(&self) -> impl Iterator<Item = MarkerIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m166[0m [1m[94m|[0m     pub fn haplotype_indices(&self) -> impl Iterator<Item = HapIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m171[0m [1m[94m|[0m     pub fn haplotype(&self, hap: HapIdx) -> Vec<u8> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m176[0m [1m[94m|[0m     pub fn alleles_at_marker(&self, marker: MarkerIdx) -> Vec<u8> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m184[0m [1m[94m|[0m     pub fn set_phased(&mut self, phased: bool) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m189[0m [1m[94m|[0m     pub fn set_reversed(&mut self, reversed: bool) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m194[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m200[0m [1m[94m|[0m     pub fn column_mut(&mut self, idx: MarkerIdx) -> &mut GenotypeColumn {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m205[0m [1m[94m|[0m     pub fn set_column(&mut self, idx: MarkerIdx, column: GenotypeColumn) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m210[0m [1m[94m|[0m     pub fn push(&mut self, marker: Marker, column: GenotypeColumn) {
    [1m[94m|[0m            [1m[33m^^^^[0m

[1m[33mwarning[0m[1m: struct `GenotypeMatrixView` is never constructed[0m
   [1m[94m--> [0msrc/data/storage/matrix.rs:217:12
    [1m[94m|[0m
[1m[94m217[0m [1m[94m|[0m pub struct GenotypeMatrixView<'a> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/data/storage/matrix.rs:224:12
    [1m[94m|[0m
[1m[94m222[0m [1m[94m|[0m impl<'a> GenotypeMatrixView<'a> {
    [1m[94m|[0m [1m[94m-------------------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m223[0m [1m[94m|[0m     /// Create a view into a matrix
[1m[94m224[0m [1m[94m|[0m     pub fn new(matrix: &'a GenotypeMatrix, marker_range: Range<usize>) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m229[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m234[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m239[0m [1m[94m|[0m     pub fn allele(&self, marker_offset: usize, hap: HapIdx) -> u8 {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m245[0m [1m[94m|[0m     pub fn marker(&self, marker_offset: usize) -> &Marker {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m251[0m [1m[94m|[0m     pub fn column(&self, marker_offset: usize) -> &GenotypeColumn {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m257[0m [1m[94m|[0m     pub fn to_owned(&self) -> GenotypeMatrix {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `marker_alleles_mut`, `swap_range`, `copy_from`, and `raw_alleles` are never used[0m
   [1m[94m--> [0msrc/data/storage/mutable.rs:72:12
    [1m[94m|[0m
[1m[94m 20[0m [1m[94m|[0m impl MutableGenotypes {
    [1m[94m|[0m [1m[94m---------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 72[0m [1m[94m|[0m     pub fn marker_alleles_mut(&mut self, marker: usize) -> &mut [u8] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 91[0m [1m[94m|[0m     pub fn swap_range(&mut self, markers: &[usize], hap1: HapIdx, hap2: HapIdx) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m100[0m [1m[94m|[0m     pub fn copy_from(&mut self, other: &MutableGenotypes) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m109[0m [1m[94m|[0m     pub fn raw_alleles(&self) -> &[Vec<u8>] {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `is_carrier`, `maf`, `size_bytes`, and `iter` are never used[0m
   [1m[94m--> [0msrc/data/storage/sparse.rs:73:12
    [1m[94m|[0m
[1m[94m 22[0m [1m[94m|[0m impl SparseColumn {
    [1m[94m|[0m [1m[94m-----------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 73[0m [1m[94m|[0m     pub fn is_carrier(&self, hap: HapIdx) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m 97[0m [1m[94m|[0m     pub fn maf(&self) -> f64 {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m107[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m113[0m [1m[94m|[0m     pub fn iter(&self) -> impl Iterator<Item = u8> + '_ {
    [1m[94m|[0m            [1m[33m^^^^[0m

[1m[33mwarning[0m[1m: field `n_haplotypes` is never read[0m
   [1m[94m--> [0msrc/data/storage/sparse.rs:130:5
    [1m[94m|[0m
[1m[94m125[0m [1m[94m|[0m pub struct SparseMultiAllelic {
    [1m[94m|[0m            [1m[94m------------------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m130[0m [1m[94m|[0m     n_haplotypes: u32,
    [1m[94m|[0m     [1m[33m^^^^^^^^^^^^[0m
    [1m[94m|[0m
    [1m[94m= [0m[1mnote[0m: `SparseMultiAllelic` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `n_haplotypes`, `n_entries`, and `size_bytes` are never used[0m
   [1m[94m--> [0msrc/data/storage/sparse.rs:153:12
    [1m[94m|[0m
[1m[94m133[0m [1m[94m|[0m impl SparseMultiAllelic {
    [1m[94m|[0m [1m[94m-----------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m153[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m158[0m [1m[94m|[0m     pub fn n_entries(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m163[0m [1m[94m|[0m     pub fn size_bytes(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: method `markers` is never used[0m
  [1m[94m--> [0msrc/data/storage/view.rs:58:12
   [1m[94m|[0m
[1m[94m24[0m [1m[94m|[0m impl<'a> GenotypeView<'a> {
   [1m[94m|[0m [1m[94m-------------------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m58[0m [1m[94m|[0m     pub fn markers(&self) -> &Markers {
   [1m[94m|[0m            [1m[33m^^^^^^^[0m

[1m[33mwarning[0m[1m: variants `InvalidData` and `Algorithm` are never constructed[0m
  [1m[94m--> [0msrc/error.rs:21:5
   [1m[94m|[0m
[1m[94m10[0m [1m[94m|[0m pub enum ReagleError {
   [1m[94m|[0m          [1m[94m-----------[0m [1m[94mvariants in this enum[0m
[1m[94m...[0m
[1m[94m21[0m [1m[94m|[0m     InvalidData { message: String },
   [1m[94m|[0m     [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m25[0m [1m[94m|[0m     Algorithm { message: String },
   [1m[94m|[0m     [1m[33m^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `ReagleError` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: associated functions `invalid_data` and `algorithm` are never used[0m
  [1m[94m--> [0msrc/error.rs:52:12
   [1m[94m|[0m
[1m[94m43[0m [1m[94m|[0m impl ReagleError {
   [1m[94m|[0m [1m[94m----------------[0m [1m[94massociated functions in this implementation[0m
[1m[94m...[0m
[1m[94m52[0m [1m[94m|[0m     pub fn invalid_data(message: impl Into<String>) -> Self {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m59[0m [1m[94m|[0m     pub fn algorithm(message: impl Into<String>) -> Self {
   [1m[94m|[0m            [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: fields `buffer_cm` and `max_markers` are never read[0m
  [1m[94m--> [0msrc/io/streaming.rs:35:9
   [1m[94m|[0m
[1m[94m29[0m [1m[94m|[0m pub struct StreamingConfig {
   [1m[94m|[0m            [1m[94m---------------[0m [1m[94mfields in this struct[0m
[1m[94m...[0m
[1m[94m35[0m [1m[94m|[0m     pub buffer_cm: f32,
   [1m[94m|[0m         [1m[33m^^^^^^^^^[0m
[1m[94m36[0m [1m[94m|[0m     /// Maximum markers per window
[1m[94m37[0m [1m[94m|[0m     pub max_markers: usize,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `StreamingConfig` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: struct `StreamWindow` is never constructed[0m
  [1m[94m--> [0msrc/io/streaming.rs:53:12
   [1m[94m|[0m
[1m[94m53[0m [1m[94m|[0m pub struct StreamWindow {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `BufferedMarker` is never constructed[0m
  [1m[94m--> [0msrc/io/streaming.rs:73:8
   [1m[94m|[0m
[1m[94m73[0m [1m[94m|[0m struct BufferedMarker {
   [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `StreamingVcfReader` is never constructed[0m
  [1m[94m--> [0msrc/io/streaming.rs:80:12
   [1m[94m|[0m
[1m[94m80[0m [1m[94m|[0m pub struct StreamingVcfReader {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/io/streaming.rs:107:12
    [1m[94m|[0m
[1m[94m105[0m [1m[94m|[0m impl StreamingVcfReader {
    [1m[94m|[0m [1m[94m-----------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m106[0m [1m[94m|[0m     /// Open a VCF file for streaming
[1m[94m107[0m [1m[94m|[0m     pub fn open(
    [1m[94m|[0m            [1m[33m^^^^[0m
[1m[94m...[0m
[1m[94m129[0m [1m[94m|[0m     pub fn from_reader(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m183[0m [1m[94m|[0m     pub fn samples(&self) -> &Samples {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m188[0m [1m[94m|[0m     pub fn samples_arc(&self) -> Arc<Samples> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m195[0m [1m[94m|[0m     pub fn next_window(&mut self) -> Result<Option<StreamWindow>> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m288[0m [1m[94m|[0m     fn fill_buffer_to_window(&mut self) -> Result<()> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m315[0m [1m[94m|[0m     fn read_next_marker(&mut self) -> Result<Option<BufferedMarker>> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m335[0m [1m[94m|[0m     fn parse_vcf_line(&mut self, line: &str) -> Result<BufferedMarker> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `StreamingPipeline` is never constructed[0m
   [1m[94m--> [0msrc/io/streaming.rs:452:12
    [1m[94m|[0m
[1m[94m452[0m [1m[94m|[0m pub struct StreamingPipeline<F>
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new` and `run` are never used[0m
   [1m[94m--> [0msrc/io/streaming.rs:465:12
    [1m[94m|[0m
[1m[94m460[0m [1m[94m|[0m [1m[94m/[0m impl<F> StreamingPipeline<F>
[1m[94m461[0m [1m[94m|[0m [1m[94m|[0m where
[1m[94m462[0m [1m[94m|[0m [1m[94m|[0m     F: FnMut(&StreamWindow) -> Result<Vec<u8>>,
    [1m[94m|[0m [1m[94m|_______________________________________________-[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m465[0m [1m[94m|[0m       pub fn new(reader: StreamingVcfReader, processor: F) -> Self {
    [1m[94m|[0m              [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m470[0m [1m[94m|[0m       pub fn run(&mut self, output_path: &Path) -> Result<()> {
    [1m[94m|[0m              [1m[33m^^^[0m

[1m[33mwarning[0m[1m: method `add_haploid` is never used[0m
  [1m[94m--> [0msrc/io/vcf.rs:64:12
   [1m[94m|[0m
[1m[94m35[0m [1m[94m|[0m impl MarkerImputationStats {
   [1m[94m|[0m [1m[94m--------------------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m64[0m [1m[94m|[0m     pub fn add_haploid(&mut self, probs: &[f32]) {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: field `header` is never read[0m
   [1m[94m--> [0msrc/io/vcf.rs:159:5
    [1m[94m|[0m
[1m[94m157[0m [1m[94m|[0m pub struct VcfReader {
    [1m[94m|[0m            [1m[94m---------[0m [1m[94mfield in this struct[0m
[1m[94m158[0m [1m[94m|[0m     /// The VCF header
[1m[94m159[0m [1m[94m|[0m     header: Header,
    [1m[94m|[0m     [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: methods `samples` and `header` are never used[0m
   [1m[94m--> [0msrc/io/vcf.rs:225:12
    [1m[94m|[0m
[1m[94m164[0m [1m[94m|[0m impl VcfReader {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m225[0m [1m[94m|[0m     pub fn samples(&self) -> &Samples {
    [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m235[0m [1m[94m|[0m     pub fn header(&self) -> &Header {
    [1m[94m|[0m            [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: method `write_imputed` is never used[0m
   [1m[94m--> [0msrc/io/vcf.rs:554:12
    [1m[94m|[0m
[1m[94m460[0m [1m[94m|[0m impl VcfWriter {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m554[0m [1m[94m|[0m     pub fn write_imputed(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: fields `ref_gt`, `gen_map`, and `indices` are never read[0m
  [1m[94m--> [0msrc/io/window.rs:17:9
   [1m[94m|[0m
[1m[94m12[0m [1m[94m|[0m pub struct Window {
   [1m[94m|[0m            [1m[94m------[0m [1m[94mfields in this struct[0m
[1m[94m...[0m
[1m[94m17[0m [1m[94m|[0m     pub ref_gt: Option<GenotypeMatrix>,
   [1m[94m|[0m         [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m20[0m [1m[94m|[0m     pub gen_map: GeneticMap,
   [1m[94m|[0m         [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m23[0m [1m[94m|[0m     pub indices: WindowIndices,
   [1m[94m|[0m         [1m[33m^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `Window` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: multiple fields are never read[0m
  [1m[94m--> [0msrc/io/window.rs:33:9
   [1m[94m|[0m
[1m[94m31[0m [1m[94m|[0m pub struct WindowIndices {
   [1m[94m|[0m            [1m[94m-------------[0m [1m[94mfields in this struct[0m
[1m[94m32[0m [1m[94m|[0m     /// Start marker index (inclusive) in the full dataset
[1m[94m33[0m [1m[94m|[0m     pub start: usize,
   [1m[94m|[0m         [1m[33m^^^^^[0m
[1m[94m34[0m [1m[94m|[0m     /// End marker index (exclusive) in the full dataset
[1m[94m35[0m [1m[94m|[0m     pub end: usize,
   [1m[94m|[0m         [1m[33m^^^[0m
[1m[94m36[0m [1m[94m|[0m     /// Previous splice point (where output starts)
[1m[94m37[0m [1m[94m|[0m     pub prev_splice: usize,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^[0m
[1m[94m38[0m [1m[94m|[0m     /// Next splice point (where output ends)
[1m[94m39[0m [1m[94m|[0m     pub next_splice: usize,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^[0m
[1m[94m40[0m [1m[94m|[0m     /// Overlap start (where next window's data begins)
[1m[94m41[0m [1m[94m|[0m     pub overlap_start: usize,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^^[0m
[1m[94m42[0m [1m[94m|[0m     /// Number of target markers
[1m[94m43[0m [1m[94m|[0m     pub n_targ_markers: usize,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m44[0m [1m[94m|[0m     /// Number of reference markers (if imputing)
[1m[94m45[0m [1m[94m|[0m     pub n_ref_markers: usize,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `WindowIndices` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `n_markers` and `n_output_markers` are never used[0m
  [1m[94m--> [0msrc/io/window.rs:50:12
   [1m[94m|[0m
[1m[94m48[0m [1m[94m|[0m impl WindowIndices {
   [1m[94m|[0m [1m[94m------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m49[0m [1m[94m|[0m     /// Number of markers in the window
[1m[94m50[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m55[0m [1m[94m|[0m     pub fn n_output_markers(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `n_samples`, `n_haplotypes`, `has_ref`, and `gen_dist` are never used[0m
  [1m[94m--> [0msrc/io/window.rs:84:12
   [1m[94m|[0m
[1m[94m60[0m [1m[94m|[0m impl Window {
   [1m[94m|[0m [1m[94m-----------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m84[0m [1m[94m|[0m     pub fn n_samples(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m89[0m [1m[94m|[0m     pub fn n_haplotypes(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m94[0m [1m[94m|[0m     pub fn has_ref(&self) -> bool {
   [1m[94m|[0m            [1m[33m^^^^^^^[0m
[1m[94m...[0m
[1m[94m99[0m [1m[94m|[0m     pub fn gen_dist(&self, m1: usize, m2: usize) -> f64 {
   [1m[94m|[0m            [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: field `buffer_cm` is never read[0m
   [1m[94m--> [0msrc/io/window.rs:115:5
    [1m[94m|[0m
[1m[94m107[0m [1m[94m|[0m pub struct WindowBuilder {
    [1m[94m|[0m            [1m[94m-------------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m115[0m [1m[94m|[0m     buffer_cm: f32,
    [1m[94m|[0m     [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `max_markers` and `buffer_cm` are never used[0m
   [1m[94m--> [0msrc/io/window.rs:142:12
    [1m[94m|[0m
[1m[94m118[0m [1m[94m|[0m impl WindowBuilder {
    [1m[94m|[0m [1m[94m------------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m142[0m [1m[94m|[0m     pub fn max_markers(mut self, n: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m148[0m [1m[94m|[0m     pub fn buffer_cm(mut self, cm: f32) -> Self {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated functions `fwd_update_alleles` and `bwd_update_alleles` are never used[0m
   [1m[94m--> [0msrc/model/hmm.rs:106:12
    [1m[94m|[0m
[1m[94m 34[0m [1m[94m|[0m impl HmmUpdater {
    [1m[94m|[0m [1m[94m---------------[0m [1m[94massociated functions in this implementation[0m
[1m[94m...[0m
[1m[94m106[0m [1m[94m|[0m     pub fn fwd_update_alleles(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m131[0m [1m[94m|[0m     pub fn bwd_update_alleles(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated function `from_gen_dists` is never used[0m
   [1m[94m--> [0msrc/model/hmm.rs:194:12
    [1m[94m|[0m
[1m[94m171[0m [1m[94m|[0m impl<'a> LiStephensHmm<'a> {
    [1m[94m|[0m [1m[94m--------------------------[0m [1m[94massociated function in this implementation[0m
[1m[94m...[0m
[1m[94m194[0m [1m[94m|[0m     pub fn from_gen_dists(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `PhasingHmm` is never constructed[0m
   [1m[94m--> [0msrc/model/hmm.rs:434:12
    [1m[94m|[0m
[1m[94m434[0m [1m[94m|[0m pub struct PhasingHmm<'a> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new` and `phase_sample` are never used[0m
   [1m[94m--> [0msrc/model/hmm.rs:443:12
    [1m[94m|[0m
[1m[94m441[0m [1m[94m|[0m impl<'a> PhasingHmm<'a> {
    [1m[94m|[0m [1m[94m-----------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m442[0m [1m[94m|[0m     /// Create a new phasing HMM
[1m[94m443[0m [1m[94m|[0m     pub fn new(ref_gt: &'a GenotypeMatrix, params: &'a ModelParams) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m460[0m [1m[94m|[0m     pub fn phase_sample(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: constant `MIN_IBS2_CM` is never used[0m
  [1m[94m--> [0msrc/model/ibs2.rs:19:7
   [1m[94m|[0m
[1m[94m19[0m [1m[94m|[0m const MIN_IBS2_CM: f64 = 2.0;
   [1m[94m|[0m       [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: constant `MAX_IBS2_GAP_CM` is never used[0m
  [1m[94m--> [0msrc/model/ibs2.rs:22:7
   [1m[94m|[0m
[1m[94m22[0m [1m[94m|[0m const MAX_IBS2_GAP_CM: f64 = 4.0;
   [1m[94m|[0m       [1m[33m^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: field `other_sample` is never read[0m
  [1m[94m--> [0msrc/model/ibs2.rs:28:9
   [1m[94m|[0m
[1m[94m26[0m [1m[94m|[0m pub struct Ibs2Segment {
   [1m[94m|[0m            [1m[94m-----------[0m [1m[94mfield in this struct[0m
[1m[94m27[0m [1m[94m|[0m     /// The other sample in the IBS2 relationship
[1m[94m28[0m [1m[94m|[0m     pub other_sample: SampleIdx,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `Ibs2Segment` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: fields `n_markers` and `sample_segs` are never read[0m
  [1m[94m--> [0msrc/model/ibs2.rs:58:5
   [1m[94m|[0m
[1m[94m56[0m [1m[94m|[0m pub struct Ibs2 {
   [1m[94m|[0m            [1m[94m----[0m [1m[94mfields in this struct[0m
[1m[94m57[0m [1m[94m|[0m     /// Number of markers
[1m[94m58[0m [1m[94m|[0m     n_markers: usize,
   [1m[94m|[0m     [1m[33m^^^^^^^^^[0m
[1m[94m59[0m [1m[94m|[0m     /// IBS2 segments for each sample: sample_segs[sample_idx] = Vec<Ibs2Segment>
[1m[94m60[0m [1m[94m|[0m     sample_segs: Vec<Vec<Ibs2Segment>>,
   [1m[94m|[0m     [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: multiple associated items are never used[0m
   [1m[94m--> [0msrc/model/ibs2.rs:70:12
    [1m[94m|[0m
[1m[94m 63[0m [1m[94m|[0m impl Ibs2 {
    [1m[94m|[0m [1m[94m---------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m 70[0m [1m[94m|[0m     pub fn new(gt: &GenotypeMatrix, gen_map: &GeneticMap, maf: &[f32]) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m 92[0m [1m[94m|[0m     fn build_sample_segments(
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m118[0m [1m[94m|[0m     fn merge_segments(segments: Vec<Ibs2Segment>, gen_map: &GeneticMap) -> Vec<Ibs2Segment> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m147[0m [1m[94m|[0m     fn gap_cm(prev: &Ibs2Segment, next: &Ibs2Segment, gen_map: &GeneticMap) -> f64 {
    [1m[94m|[0m        [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m153[0m [1m[94m|[0m     fn extend_segments(
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m182[0m [1m[94m|[0m     fn filter_by_length(segments: Vec<Ibs2Segment>, gen_map: &GeneticMap) -> Vec<Ibs2Segment> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m195[0m [1m[94m|[0m     fn is_ibs2_at(gt: &GenotypeMatrix, marker: usize, s1: SampleIdx, s2: SampleIdx) -> bool {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m212[0m [1m[94m|[0m     pub fn n_markers(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m217[0m [1m[94m|[0m     pub fn n_samples(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m222[0m [1m[94m|[0m     pub fn n_segments(&self, sample: SampleIdx) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m230[0m [1m[94m|[0m     pub fn are_ibs2(&self, sample: SampleIdx, other: SampleIdx, marker: usize) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m250[0m [1m[94m|[0m     pub fn are_ibs2_in_interval(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m279[0m [1m[94m|[0m     pub fn segments(&self, sample: SampleIdx) -> &[Ibs2Segment] {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m287[0m [1m[94m|[0m     pub fn ibs2_samples_at(&self, sample: SampleIdx, marker: usize) -> Vec<SampleIdx> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `Ibs2Markers` is never constructed[0m
   [1m[94m--> [0msrc/model/ibs2.rs:306:8
    [1m[94m|[0m
[1m[94m306[0m [1m[94m|[0m struct Ibs2Markers {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `MIN_MAF`, `new`, and `len` are never used[0m
   [1m[94m--> [0msrc/model/ibs2.rs:313:11
    [1m[94m|[0m
[1m[94m311[0m [1m[94m|[0m impl Ibs2Markers {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94massociated items in this implementation[0m
[1m[94m312[0m [1m[94m|[0m     /// Minimum MAF for informative markers
[1m[94m313[0m [1m[94m|[0m     const MIN_MAF: f32 = 0.05;
    [1m[94m|[0m           [1m[33m^^^^^^^[0m
[1m[94m314[0m [1m[94m|[0m
[1m[94m315[0m [1m[94m|[0m     fn new(gt: &GenotypeMatrix, maf: &[f32]) -> Self {
    [1m[94m|[0m        [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m329[0m [1m[94m|[0m     fn len(&self) -> usize {
    [1m[94m|[0m        [1m[33m^^^[0m

[1m[33mwarning[0m[1m: struct `Ibs2Sets` is never constructed[0m
   [1m[94m--> [0msrc/model/ibs2.rs:335:8
    [1m[94m|[0m
[1m[94m335[0m [1m[94m|[0m struct Ibs2Sets {
    [1m[94m|[0m        [1m[33m^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new` and `segments_for_sample` are never used[0m
   [1m[94m--> [0msrc/model/ibs2.rs:342:8
    [1m[94m|[0m
[1m[94m341[0m [1m[94m|[0m impl Ibs2Sets {
    [1m[94m|[0m [1m[94m-------------[0m [1m[94massociated items in this implementation[0m
[1m[94m342[0m [1m[94m|[0m     fn new(gt: &GenotypeMatrix, ibs2_markers: &Ibs2Markers) -> Self {
    [1m[94m|[0m        [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m391[0m [1m[94m|[0m     fn segments_for_sample(&self, sample: SampleIdx) -> Vec<Ibs2Segment> {
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: fields `ne` and `use_em` are never read[0m
  [1m[94m--> [0msrc/model/parameters.rs:14:9
   [1m[94m|[0m
[1m[94m11[0m [1m[94m|[0m pub struct ModelParams {
   [1m[94m|[0m            [1m[94m-----------[0m [1m[94mfields in this struct[0m
[1m[94m...[0m
[1m[94m14[0m [1m[94m|[0m     pub ne: u64,
   [1m[94m|[0m         [1m[33m^^[0m
[1m[94m...[0m
[1m[94m44[0m [1m[94m|[0m     pub use_em: bool,
   [1m[94m|[0m         [1m[33m^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `ModelParams` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `switch_prob`, `no_switch_prob`, `set_ne`, and `set_n_haps` are never used[0m
   [1m[94m--> [0msrc/model/parameters.rs:177:12
    [1m[94m|[0m
[1m[94m 47[0m [1m[94m|[0m impl ModelParams {
    [1m[94m|[0m [1m[94m----------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m177[0m [1m[94m|[0m     pub fn switch_prob(&self, gen_dist_cm: f64) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m182[0m [1m[94m|[0m     pub fn no_switch_prob(&self, gen_dist_cm: f64) -> f32 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m227[0m [1m[94m|[0m     pub fn set_ne(&mut self, ne: u64) {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m240[0m [1m[94m|[0m     pub fn set_n_haps(&mut self, n_haps: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: method `sum_switch_probs` is never used[0m
   [1m[94m--> [0msrc/model/parameters.rs:307:12
    [1m[94m|[0m
[1m[94m276[0m [1m[94m|[0m impl ParamEstimates {
    [1m[94m|[0m [1m[94m-------------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m307[0m [1m[94m|[0m     pub fn sum_switch_probs(&self) -> f64 {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: methods `n_haps` and `update_with` are never used[0m
  [1m[94m--> [0msrc/model/pbwt.rs:46:12
   [1m[94m|[0m
[1m[94m32[0m [1m[94m|[0m impl PbwtUpdater {
   [1m[94m|[0m [1m[94m----------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m46[0m [1m[94m|[0m     pub fn n_haps(&self) -> usize {
   [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m87[0m [1m[94m|[0m     pub fn update_with<F>(&mut self, get_allele: F, n_alleles: usize, prefix: &mut [u32])
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: method `n_haps` is never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:156:12
    [1m[94m|[0m
[1m[94m143[0m [1m[94m|[0m impl PbwtDivUpdater {
    [1m[94m|[0m [1m[94m-------------------[0m [1m[94mmethod in this implementation[0m
[1m[94m...[0m
[1m[94m156[0m [1m[94m|[0m     pub fn n_haps(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: struct `SimpleDivUpdater` is never constructed[0m
   [1m[94m--> [0msrc/model/pbwt.rs:387:12
    [1m[94m|[0m
[1m[94m387[0m [1m[94m|[0m pub struct SimpleDivUpdater {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new` and `update` are never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:393:12
    [1m[94m|[0m
[1m[94m392[0m [1m[94m|[0m impl SimpleDivUpdater {
    [1m[94m|[0m [1m[94m---------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m393[0m [1m[94m|[0m     pub fn new(n_haps: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m401[0m [1m[94m|[0m     pub fn update(
    [1m[94m|[0m            [1m[33m^^^^^^[0m

[1m[33mwarning[0m[1m: field `bwd_updater` is never read[0m
   [1m[94m--> [0msrc/model/pbwt.rs:457:5
    [1m[94m|[0m
[1m[94m441[0m [1m[94m|[0m pub struct PbwtIbs {
    [1m[94m|[0m            [1m[94m-------[0m [1m[94mfield in this struct[0m
[1m[94m...[0m
[1m[94m457[0m [1m[94m|[0m     bwd_updater: PbwtDivUpdater,
    [1m[94m|[0m     [1m[33m^^^^^^^^^^^[0m
    [1m[94m|[0m
    [1m[94m= [0m[1mnote[0m: `PbwtIbs` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `bwd_update`, `find_position`, `select_ibs_hap`, `select_states_for_external_target`, and `find_allele_region` are never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:499:12
    [1m[94m|[0m
[1m[94m460[0m [1m[94m|[0m impl PbwtIbs {
    [1m[94m|[0m [1m[94m------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m499[0m [1m[94m|[0m     pub fn bwd_update(&mut self, alleles: &[u8], n_alleles: usize, marker: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m530[0m [1m[94m|[0m     pub fn find_position(&self, hap: HapIdx, use_backward: bool) -> Option<usize> {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m627[0m [1m[94m|[0m     pub fn select_ibs_hap(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m647[0m [1m[94m|[0m     pub fn select_states_for_external_target(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m696[0m [1m[94m|[0m     pub fn find_allele_region(
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `BidirectionalPhaseResult` is never constructed[0m
   [1m[94m--> [0msrc/model/pbwt.rs:734:12
    [1m[94m|[0m
[1m[94m734[0m [1m[94m|[0m pub struct BidirectionalPhaseResult {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `add`, `n_hets`, and `n_confident` are never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:745:12
    [1m[94m|[0m
[1m[94m743[0m [1m[94m|[0m impl BidirectionalPhaseResult {
    [1m[94m|[0m [1m[94m-----------------------------[0m [1m[94massociated items in this implementation[0m
[1m[94m744[0m [1m[94m|[0m     /// Create a new result with the given capacity
[1m[94m745[0m [1m[94m|[0m     pub fn new(capacity: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m754[0m [1m[94m|[0m     pub fn add(&mut self, marker: usize, decision: bool, confident: bool) {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m761[0m [1m[94m|[0m     pub fn n_hets(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m766[0m [1m[94m|[0m     pub fn n_confident(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `run_bidirectional_pbwt_phasing` is never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:787:8
    [1m[94m|[0m
[1m[94m787[0m [1m[94m|[0m pub fn run_bidirectional_pbwt_phasing(
    [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: function `build_pbwt_matches` is never used[0m
   [1m[94m--> [0msrc/model/pbwt.rs:860:4
    [1m[94m|[0m
[1m[94m860[0m [1m[94m|[0m fn build_pbwt_matches(
    [1m[94m|[0m    [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `WindowResult` is never constructed[0m
  [1m[94m--> [0msrc/pipelines/imputation.rs:36:12
   [1m[94m|[0m
[1m[94m36[0m [1m[94m|[0m pub struct WindowResult {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated function `new` is never used[0m
  [1m[94m--> [0msrc/pipelines/imputation.rs:47:12
   [1m[94m|[0m
[1m[94m45[0m [1m[94m|[0m impl WindowResult {
   [1m[94m|[0m [1m[94m-----------------[0m [1m[94massociated function in this implementation[0m
[1m[94m46[0m [1m[94m|[0m     /// Create new window result
[1m[94m47[0m [1m[94m|[0m     pub fn new(n_markers: usize, n_samples: usize, indices: WindowIndices) -> Self {
   [1m[94m|[0m            [1m[33m^^^[0m

[1m[33mwarning[0m[1m: function `splice_window_results` is never used[0m
  [1m[94m--> [0msrc/pipelines/imputation.rs:68:8
   [1m[94m|[0m
[1m[94m68[0m [1m[94m|[0m pub fn splice_window_results(
   [1m[94m|[0m        [1m[33m^^^^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `StageMarkers` is never constructed[0m
  [1m[94m--> [0msrc/pipelines/phasing.rs:34:12
   [1m[94m|[0m
[1m[94m34[0m [1m[94m|[0m pub struct StageMarkers {
   [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `classify`, `is_stage1`, `n_stage1`, `stage1_marker`, and `is_allele_low_freq` are never used[0m
   [1m[94m--> [0msrc/pipelines/phasing.rs:56:12
    [1m[94m|[0m
[1m[94m 49[0m [1m[94m|[0m impl StageMarkers {
    [1m[94m|[0m [1m[94m-----------------[0m [1m[94massociated items in this implementation[0m
[1m[94m...[0m
[1m[94m 56[0m [1m[94m|[0m     pub fn classify(
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m160[0m [1m[94m|[0m     pub fn is_stage1(&self, marker: usize) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m165[0m [1m[94m|[0m     pub fn n_stage1(&self) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m170[0m [1m[94m|[0m     pub fn stage1_marker(&self, stage1_idx: usize) -> usize {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m175[0m [1m[94m|[0m     pub fn is_allele_low_freq(&self, marker: usize, allele: u8) -> bool {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: fields `ref_haps` and `switch_probs` are never read[0m
  [1m[94m--> [0msrc/utils/workspace.rs:36:9
   [1m[94m|[0m
[1m[94m16[0m [1m[94m|[0m pub struct Workspace {
   [1m[94m|[0m            [1m[94m---------[0m [1m[94mfields in this struct[0m
[1m[94m...[0m
[1m[94m36[0m [1m[94m|[0m     pub ref_haps: Vec<HapIdx>,
   [1m[94m|[0m         [1m[33m^^^^^^^^[0m
[1m[94m...[0m
[1m[94m42[0m [1m[94m|[0m     pub switch_probs: Vec<f32>,
   [1m[94m|[0m         [1m[33m^^^^^^^^^^^^[0m
   [1m[94m|[0m
   [1m[94m= [0m[1mnote[0m: `Workspace` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

[1m[33mwarning[0m[1m: methods `clear`, `reset_pbwt`, `init_fwd_uniform`, and `init_bwd_ones` are never used[0m
   [1m[94m--> [0msrc/utils/workspace.rs:98:12
    [1m[94m|[0m
[1m[94m 51[0m [1m[94m|[0m impl Workspace {
    [1m[94m|[0m [1m[94m--------------[0m [1m[94mmethods in this implementation[0m
[1m[94m...[0m
[1m[94m 98[0m [1m[94m|[0m     pub fn clear(&mut self) {
    [1m[94m|[0m            [1m[33m^^^^^[0m
[1m[94m...[0m
[1m[94m111[0m [1m[94m|[0m     pub fn reset_pbwt(&mut self, n_haps: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m123[0m [1m[94m|[0m     pub fn init_fwd_uniform(&mut self, n_states: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^^^^[0m
[1m[94m...[0m
[1m[94m131[0m [1m[94m|[0m     pub fn init_bwd_ones(&mut self, n_states: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: struct `ImpWorkspace` is never constructed[0m
   [1m[94m--> [0msrc/utils/workspace.rs:184:12
    [1m[94m|[0m
[1m[94m184[0m [1m[94m|[0m pub struct ImpWorkspace {
    [1m[94m|[0m            [1m[33m^^^^^^^^^^^^[0m

[1m[33mwarning[0m[1m: associated items `new`, `resize`, and `clear` are never used[0m
   [1m[94m--> [0msrc/utils/workspace.rs:206:12
    [1m[94m|[0m
[1m[94m204[0m [1m[94m|[0m impl ImpWorkspace {
    [1m[94m|[0m [1m[94m-----------------[0m [1m[94massociated items in this implementation[0m
[1m[94m205[0m [1m[94m|[0m     /// Create a new imputation workspace
[1m[94m206[0m [1m[94m|[0m     pub fn new(n_states: usize, n_markers: usize) -> Self {
    [1m[94m|[0m            [1m[33m^^^[0m
[1m[94m...[0m
[1m[94m218[0m [1m[94m|[0m     pub fn resize(&mut self, n_states: usize, n_markers: usize) {
    [1m[94m|[0m            [1m[33m^^^^^^[0m
[1m[94m...[0m
[1m[94m228[0m [1m[94m|[0m     pub fn clear(&mut self) {
    [1m[94m|[0m            [1m[33m^^^^^[0m

[1m[33mwarning[0m: `reagle` (bin "reagle" test) generated 99 warnings (run `cargo fix --bin "reagle" -p reagle --tests` to apply 12 suggestions)
[1m[92m    Finished[0m `test` profile [unoptimized + debuginfo] target(s) in 8.49s
[1m[92m     Running[0m unittests src/lib.rs (target/debug/deps/reagle-16500524a0f8136e)

running 77 tests
test data::genetic_map::tests::test_empty_map ... ok
test data::genetic_map::tests::test_extrapolation ... ok
test config::tests::test_li_stephens_mismatch ... ok
test data::genetic_map::tests::test_gen_dist ... ok
test data::genetic_map::tests::test_marker_map_from_positions ... ok
test data::genetic_map::tests::test_interpolation ... ok
test data::genetic_map::tests::test_marker_map_restrict ... ok
test data::genetic_map::tests::test_position_map ... ok
test data::genetic_map::tests::test_marker_map_p_recomb ... ok
test data::haplotype::tests::test_sample_hap_indices ... ok
test data::marker::tests::test_allele_from_char ... ok
test data::haplotype::tests::test_samples_lookup ... ok
test data::haplotype::tests::test_samples_n_haps ... ok
test data::haplotype::tests::test_hap_sample_index ... ok
test data::marker::tests::test_bits_per_allele ... ok
test data::marker::tests::test_marker_is_snv ... ok
test data::storage::coded_steps::tests::test_coded_step ... ok
test data::storage::coded_steps::tests::test_coded_pbwt ... ok
test data::storage::coded_steps::tests::test_compute_step_starts ... ok
test data::storage::dense::tests::test_set ... ok
test data::storage::coded_steps::tests::test_ref_panel_coded ... ok
test data::storage::dense::tests::test_biallelic ... ok
test data::storage::dense::tests::test_multiallelic ... ok
test data::storage::dictionary::tests::test_dictionary_compression ... ok
test data::storage::matrix::tests::test_genotype ... ok
test data::storage::matrix::tests::test_matrix_access ... ok
test data::storage::mutable::tests::test_haplotype ... ok
test data::storage::matrix::tests::test_matrix_restrict ... ok
test data::storage::mutable::tests::test_mutable_genotypes ... ok
test data::storage::mutable::tests::test_swap ... ok
test data::storage::sparse::tests::test_sparse_column ... ok
test data::storage::sparse::tests::test_sparse_inverted ... ok
test data::storage::sparse::tests::test_sparse_multiallelic ... ok
test data::storage::tests::test_maf_calculation ... ok
test data::storage::view::tests::test_view_from_matrix ... ok
test data::storage::view::tests::test_view_from_mutable ... ok
test data::storage::tests::test_storage_selection ... ok
test io::streaming::tests::test_parse_gt ... ok
test io::streaming::tests::test_streaming_config_default ... ok
test io::vcf::tests::test_dr2_variable_imputation ... ok
test io::vcf::tests::test_allele_frequency ... ok
test io::vcf::tests::test_dr2_perfect_imputation ... ok
test io::vcf::tests::test_dr2_uncertain_imputation ... ok
test io::vcf::tests::test_marker_imputation_stats_new ... ok
test io::vcf::tests::test_imputation_quality_collection ... ok
test io::vcf::tests::test_parse_genotype ... ok
test io::vcf::tests::test_parse_genotype_multiallelic ... ok
test io::window::tests::test_single_window ... ok
test model::hmm::tests::test_hmm_forward_backward ... ok
test model::hmm::tests::test_hmm_updater_bwd ... ok
test model::hmm::tests::test_hmm_updater_fwd ... ok
test io::window::tests::test_window_builder ... ok
test model::ibs2::tests::test_ibs2_segment ... ok
test model::hmm::tests::test_dosage_computation ... ok
test model::hmm::tests::test_gen_dist_to_p_recomb ... ok
test model::imp_states::tests::test_coded_steps ... ok
test model::ibs2::tests::test_phase_consistent ... ok
test model::imp_states::tests::test_composite_hap ... ok
test model::parameters::tests::test_li_stephens_p_mismatch ... ok
test model::imp_states::tests::test_imp_ibs ... ok
test model::parameters::tests::test_emit_probs ... ok
test model::parameters::tests::test_lr_threshold_for_iteration ... ok
test model::parameters::tests::test_ne_from_recomb_intensity ... ok
test model::parameters::tests::test_p_recomb ... ok
test model::parameters::tests::test_param_estimates_merge ... ok
test model::parameters::tests::test_recomb_intensity_formula ... ok
test model::pbwt::tests::test_find_ibs_neighbors ... ok
test model::pbwt::tests::test_pbwt_ibs_select ... ok
test model::pbwt::tests::test_pbwt_div_bwd_update ... ok
test model::pbwt::tests::test_pbwt_div_fwd_update ... ok
test model::pbwt::tests::test_pbwt_update ... ok
test pipelines::imputation::tests::test_impute_haplotype ... ok
test pipelines::imputation::tests::test_imp_ls_baum ... ok
test pipelines::phasing::tests::test_pipeline_creation ... ok
test utils::workspace::tests::test_workspace_creation ... ok
test utils::workspace::tests::test_workspace_resize ... ok
test utils::workspace::tests::test_random_sampling ... ok

test result: ok. 77 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

[1m[92m     Running[0m unittests src/main.rs (target/debug/deps/reagle-1426dc9efcf1b97d)

running 78 tests
test config::tests::test_li_stephens_mismatch ... ok
test data::genetic_map::tests::test_empty_map ... ok
test data::genetic_map::tests::test_gen_dist ... ok
test data::genetic_map::tests::test_extrapolation ... ok
test data::genetic_map::tests::test_interpolation ... ok
test data::genetic_map::tests::test_marker_map_from_positions ... ok
test data::genetic_map::tests::test_marker_map_restrict ... ok
test data::genetic_map::tests::test_position_map ... ok
test data::genetic_map::tests::test_marker_map_p_recomb ... ok
test data::haplotype::tests::test_hap_sample_index ... ok
test data::haplotype::tests::test_sample_hap_indices ... ok
test data::haplotype::tests::test_samples_n_haps ... ok
test data::haplotype::tests::test_samples_lookup ... ok
test data::marker::tests::test_allele_from_char ... ok
test data::marker::tests::test_bits_per_allele ... ok
test data::marker::tests::test_marker_is_snv ... ok
test data::storage::coded_steps::tests::test_coded_step ... ok
test data::storage::coded_steps::tests::test_coded_pbwt ... ok
test data::storage::coded_steps::tests::test_compute_step_starts ... ok
test data::storage::dense::tests::test_biallelic ... ok
test data::storage::coded_steps::tests::test_ref_panel_coded ... ok
test data::storage::dense::tests::test_multiallelic ... ok
test data::storage::dense::tests::test_set ... ok
test data::storage::matrix::tests::test_matrix_restrict ... ok
test data::storage::dictionary::tests::test_dictionary_compression ... ok
test data::storage::matrix::tests::test_genotype ... ok
test data::storage::matrix::tests::test_matrix_access ... ok
test data::storage::mutable::tests::test_haplotype ... ok
test data::storage::mutable::tests::test_mutable_genotypes ... ok
test data::storage::mutable::tests::test_swap ... ok
test data::storage::sparse::tests::test_sparse_column ... ok
test data::storage::sparse::tests::test_sparse_inverted ... ok
test data::storage::sparse::tests::test_sparse_multiallelic ... ok
test data::storage::tests::test_maf_calculation ... ok
test data::storage::view::tests::test_view_from_mutable ... ok
test data::storage::view::tests::test_view_from_matrix ... ok
test io::streaming::tests::test_parse_gt ... ok
test data::storage::tests::test_storage_selection ... ok
test io::streaming::tests::test_streaming_config_default ... ok
test io::vcf::tests::test_allele_frequency ... ok
test io::vcf::tests::test_dr2_perfect_imputation ... ok
test io::vcf::tests::test_dr2_variable_imputation ... ok
test io::vcf::tests::test_dr2_uncertain_imputation ... ok
test io::vcf::tests::test_imputation_quality_collection ... ok
test io::vcf::tests::test_marker_imputation_stats_new ... ok
test io::vcf::tests::test_parse_genotype ... ok
test io::vcf::tests::test_parse_genotype_multiallelic ... ok
test io::window::tests::test_single_window ... ok
test model::hmm::tests::test_dosage_computation ... ok
test model::hmm::tests::test_gen_dist_to_p_recomb ... ok
test model::hmm::tests::test_hmm_forward_backward ... ok
test model::hmm::tests::test_hmm_updater_bwd ... ok
test model::hmm::tests::test_hmm_updater_fwd ... ok
test io::window::tests::test_window_builder ... ok
test model::ibs2::tests::test_phase_consistent ... ok
test model::imp_states::tests::test_coded_steps ... ok
test model::ibs2::tests::test_ibs2_segment ... ok
test model::imp_states::tests::test_composite_hap ... ok
test model::parameters::tests::test_li_stephens_p_mismatch ... ok
test model::parameters::tests::test_lr_threshold_for_iteration ... ok
test model::imp_states::tests::test_imp_ibs ... ok
test model::parameters::tests::test_emit_probs ... ok
test model::parameters::tests::test_ne_from_recomb_intensity ... ok
test model::parameters::tests::test_p_recomb ... ok
test model::parameters::tests::test_recomb_intensity_formula ... ok
test model::parameters::tests::test_param_estimates_merge ... ok
test model::pbwt::tests::test_find_ibs_neighbors ... ok
test model::pbwt::tests::test_pbwt_div_bwd_update ... ok
test model::pbwt::tests::test_pbwt_div_fwd_update ... ok
test model::pbwt::tests::test_pbwt_ibs_select ... ok
test model::pbwt::tests::test_pbwt_update ... ok
test pipelines::imputation::tests::test_imp_ls_baum ... ok
test pipelines::imputation::tests::test_impute_haplotype ... ok
test pipelines::phasing::tests::test_pipeline_creation ... ok
test utils::workspace::tests::test_workspace_creation ... ok
test tests::test_module_imports ... ok
test utils::workspace::tests::test_workspace_resize ... ok
test utils::workspace::tests::test_random_sampling ... ok

test result: ok. 78 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s

[1m[92m   Doc-tests[0m reagle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

